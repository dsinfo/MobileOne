<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TheOne.EnterpriseServices</name>
    </assembly>
    <members>
        <member name="T:TheOne.EnterpriseServices.DACBase">
             <summary>
             데이터베이스를 액세스하는 COM+ 컴포넌트를 위한 추상(abstract) 클래스이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스는 <see cref="T:TheOne.EnterpriseServices.DbObjectBase">DbObjectBase</see> 클래스에서
             파생된 클래스로서 데이터베이스를 액세스하는 COM+ 컴포넌트를 위한 추상 클래스이다. 
             이 클래스는 <b>abstract</b> 클래스이므로 파생 클래스를 정의해야 하며 
             파생된 클래스는 COM+ 데이터 액세스 컴포넌트로서 작동한다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스를 사용하는 권장되는 패턴은 <see cref="T:TheOne.EnterpriseServices.DACBase"/> 에서 파생된 프로젝트(과제)만의 기본
             클래스를 작성하고 실제 구체적 업무 클래스는 프로젝트의 기본 클래스에서 파생하는 것이다.
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스는 일반적이고 다양한 용도를 위한 기본값으로 설정이 되어 있기 때문에
             각 프로젝트에서 고유한 기본 설정(연결 문자열, OpenOnActivate 설정 등)으로 변경할 수 있다.
             또한 이 클래스에서 파생된 프로젝트 레벨의 기본 클래스를 생성함으로써 얻을 수 있는 장점은
             추후에 변경될 수 있는 사항을 추가적인 기본 클래스에서 흡수하여 프로젝트 기본 클래스에서 파생하여
             구현된 구체적 업무 클래스들을 수정해야 하는 항목을 줄이는 효과를 얻을 수 있다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스 역시 <see cref="T:TheOne.EnterpriseServices.DbObjectBase">DbObjectBase</see> 클래스처럼 컴포넌트가 
            <b>Activate</b> 또는 <b>Deactivate</b> 될 때 데이터베이스 연결을 열거나 닫을 수 있다. <br/>
             그리고 이 기본 동작은
             <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성에
             의해 제어할 수 있다. <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 
             기본값은 <b>false</b> 이며, 이는 코드 내에서 명시적으로
             Open(), Close() 메서드를 호출해 주거나 DbAccess 클래스의 ExecuteSPxxx, ExecuteSQLxxx 메서드들의 자동 Open/Close
             기능에 의존해야 함을 의미한다. 만약 OpenOnActivate 속성의 값을 생성자에서 <b>trrue</b> 로 설정하면
             컴포넌트의 메서드가 호출되기 전에 Open() 메서드는 호출되어 지며 컴포넌트 메서드가 끝나면 Close()가
             호출되어 진다.
             <br/><br/>
             OpenOnActivate를 <b>false</b>로 설정하고 데이터베이스 연결을 수동으로 관리할 때는
             정확하게 Open/Close 시점을 지정할 수 있다는 점에서 효율적인 데이터베이스 연결 관리를 할 수 있다는
             장점이 있지만 Open/Close를 명시적으로 호출하기 위한 try ~ finally 문장을 사용하는 등 개발자의
             추가적인 노력이 필요한 단점이 있다.<br/>
             반면 OpenOnActivate를 <b>true</b>로 설정하고 데이터베이스 연결을 자동으로 관리하면
             코드 및 로직을 간편하게 가져 갈 수 있으므로 코딩이 보다 쉬워지지만 데이터베이스 연결이
             실제 요구하는 시점보다 조금 일찍 열리고 조금 늦게 닫히는 단점이 있다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스의 <see cref="M:TheOne.EnterpriseServices.DACBase.CreateDbInstance">CreateDbInstance</see> 메서드 구현은
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를 생성하여 반환하도록
             되어 있다. 즉, <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스에서 파생된 클래스의 <see cref="T:TheOne.Data.DbAccess">DbAccess</see>
             속성는  <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를 반환하게 된다. 따라서 데이타베이스를 액세스하는 DSL(Data Service Layer)
             컴포넌트들은 <see cref="T:TheOne.EnterpriseServices.DACBase"/>를 기본 클래스로 정의함으로써 각 클래스에서 CreateDbInstance 메서드를
             재정의 할 필요가 없게 된다. 만약 DACBase 클래스에서 파생하지 않고 직접
             DbObjectBase 클래스에서 파생된 클래스를 정의한다면 각 파생 클래스들은 CreateDbInstance 메서드를
             반드시 재정의 해야 한다.
             <br/><br/>
             CreateDbInstance 메서드가 생성하는  <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체는 NeoDEEX 구성 파일에서
             연결 문자열을 취하도록 되어 있다. 보다 구체적으로, 연결 문자열은 NeoDEEX 구성 파일의
             appSettings 섹션에서 <b>ConnectionString</b> 키가 지시하는 문자열을 사용한다.
             만약 SqlDbObject 클래스의 파생 클래스가 이 기본 행동을 바꾸고자 한다면
             CreateDbInstance 메서드를 재정의 하여 다른 연결 문자열을 사용하도록 설정할 수 있다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스에 선언된 COM+ 관련 어트리뷰트(attribute)는 이 클래스의 기본 클래스인
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase">DbObjectBase</see> 클래스의 어트리뷰트를 상속
             받는다. DbObjectBase의 트랜잭션 속성이 <b>Supported</b> 이므로 
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스에서 파생된 클래스가 명시적으로
             Transaction 어트리뷰트를 주지 않는다면 트랜잭션 속성은 <b>Supported</b>가 된다.
             Transaction Isolation Level의 기본값 설정은 <b>ReadCommitted</b> 를 사용한다.
             </remarks>
             <example>
             Micorosoft SQL Server 데이타베이스를 액세스하는 어플리케이션의 NeoDEEX 구성 파일에 다음과 같이 연결문자열을 이름/값 쌍으로 추가한다.
             설정한다.
             <code>
             &lt;?xml version="1.0" encoding="utf-8" ?&gt;
             &lt;configuration&gt;
                 &lt;databaseSection defaultDatabase="SqlProvider"&gt;
                     &lt;add name="SqlProvider" type="TheOne.Data.SqlClient.SqlDbAccess"  connectionString="server=(local);Initial Catalog=TEST;uid=user;pwd=123"/&gt;
                 &lt;/databaseSection&gt;
             &lt;/configuration&gt;
             </code>
             SQL Server를 액세스하는 데이터 액세스 컴포넌트를 DACBase에서 파생하여
             다음과 같이 작성한다.
             <code>
             public class DbComponent2 : DACBase
             {
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
            		// Open/Close method will be invoked in ExecuteSql method implicitly
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             위 코드는 NeoDEEX 구성 파일의 databaseSection에서 defaultDatabase가 지정하는 연결 문자열을 사용하여
             데이터베이스를 액세스한다. 어플리케이션의 대부분 데이터 액세스 컴포넌트가 이와 같이
             작동하지만 일부 예외적으로 다른 DB에 접근해야 하는 데이터 액세스 컴포넌트가 존재한다면
             CreateDbInstance 메서드를 재정의하여 별도의 연결문자열을 지정해 줄 수 있다.
             상세한 예제는 <see cref="M:TheOne.EnterpriseServices.DACBase.CreateDbInstance">CreateDbInstance</see> 메서드의 예제를
             참고한다.
             <br/><br/>
             다음 코드는 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성를 true로 설정하는 예제 코드이다.
             <code>
             public class DbComponent2 : DACBase
             {
             	public void DbComponent2() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		// Close() method will be called automatically
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="T:TheOne.EnterpriseServices.DbObjectBase">
             <summary>
             데이터 액세스 COM+ 컴포넌트(Data Access Component : DAC)를 위한 추상(abstract) 클래스이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스는 데이터베이스를 액세스하는 데이터 액세스 컴포넌트를 위한
             추상 클래스로서 이 클래스는 <b>abstract</b> 클래스이므로 파생 클래스를 정의해야 하며  
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를
             속성으로 제공하고 데이터베이스 연결에 대하여 열거나 닫는 기능을 자동으로 실행한다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스에서 파생된 구체(concreate) COM+ 컴포넌트 클래스는 <b>public</b> 메서드에서
             <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess">DbAccess</see> 속성을 통해 데이터베이스를 손쉽게 액세스 할 수 있다.
             DbAccess 속성이 지시하는 데이터베이스에 대한 연결은 컴포넌트가 <b>Activate</b> 와 <b>Deactivate</b>될 때
             자동으로 열고 닫히게 되므로 개발자가 데이터베이스 연결에 대한 코드를 작성할 필요가 없다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스 혹은 그 파생 클래스에서 DbAccess 속성을 통해 액세스하는 DbAccess 클래스
             혹은 그 파생 클래스의 인스턴스는 <b>abstract</b> 메서드인
             <see cref="M:TheOne.EnterpriseServices.DbObjectBase.CreateDbInstance">CrateDbInstance</see>에서 그 인스턴스를 생성하도록 되어 있다.<br/>
             즉, DbAccess 속성이 지시하는 DbAccess 객체는 CreateDbInstace 메서드에서 생성하고 반환한
             객체라는 것이다. 따라서 DbObjectBase 클래스에서 파생된 모든 클래스는 모두 CreateDbInstance 메서드를
             재정의 해야만 한다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스는 컴포넌트가 <b>Activate</b> 또는 <b>Deactivate</b>되는 시점에서 데이터베이스 연결을
             열거나 닫도록 설정할 수 있다. 이 기본 설정을 변경하기 위해서는 파생 클래스의
             생성자에서 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 값을 <b>true</b>로 설정
             해야 한다. OpenOnActivate의 기본값은 <b>false</b> 이다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스에서 직접 상속을 받고 CreateDbInstance 메서드를 재정의 할 수도 있지만
             이러한 구현이 이미 되어 있는 <see cref="T:TheOne.EnterpriseServices.DACBase">DACBase</see> 클래스에서
             데이터 액세스 컴포넌트 클래스를 파생하는 것이 좋다. 이렇게 함으로써 모든 데이터 액세스
             컴포넌트 클래스들이 CreateDbInstance 메서드를 재정의하여 중복 코드를 줄일 수 있다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스에 선언된 COM+ 관련 어트리뷰트(attribute)는 이 클래스의 기본 클래스인
             <see cref="T:TheOne.EnterpriseServices.ComponentBase">ComponentBase</see> 클래스의 어트리뷰트를 상속
             받는다. 다만, Transaction 어트리뷰트는 <b>Supported</b> 로 기본 설정되어 있다. 대개의 데이터 액세스
             컴포넌트가 Support 트랜잭션 설정을 갖기 때문이다. 이 클래스에서 파생된 클래스가 명시적으로
             Transaction 어트리뷰트를 주지 않는다면 트랜잭션 속성은 <b>Supported</b>가 된다.
             Transaction Isolation Level의 기본값 설정은 <b>ReadCommitted</b> 를 사용한다.
             <br/><br/>
             이 클래스
             </remarks>
             <example>
             <code>
             // change default transaction option
             [Transaction(TransactionOption.Required, Isolation=TransactionIsolationLevel.ReadCommitted)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		// In this case, it will be SqlDbAccess.
             		DataSet ds = this.DbAccess.ExecuteSqlDataSet("SELECT * FROM tblTest2");
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="T:TheOne.EnterpriseServices.ComponentBase">
            <summary>
            COM+ 서비스를 사용하는 컴포넌트의 기본 클래스를 정의한다.<br/>
            이 클래스에서 파생된 클래스를 정의함으로써 파일로깅, 이벤트 로깅, 성능 측정 등의
            기능이 기본적으로 제공되는 COM+ 컴포넌트를 개발할 수 있다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스는 <see ref="System.EnterpriseServices.ServicedComponent">System.EnterpriseServices.ServicedComponent</see>
            클래스에서 파생되었다. 따라서 COM+ 컴포넌트의 기본 클래스 역할을 수행할 수 있다.
            이 클래스는 추상(<b>abstract</b>) 클래스이므로 인스턴스를 생성할 수 없으며, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 에서 파생된 클래스를
            선언하고 인스턴스를 생성해야 한다.
            <br/><br/>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스에 선언된 COM+ 관련 어트리뷰트(attribute)는 <b>JustInTimeActivation</b> 어트리뷰트와
            <b>EventTrackingEnabled</b> 어트리뷰트이다. 따라서 이 클래스에서 파생된 클래스는 이 어트리뷰트를 선언할
            필요가 없다. 물론, 기본 설정된 이들 어트리뷰트를 해제하기 위해서 <b>false</b> 값으로 선언할 수는 있다.
            이 클래스에 선언된 <see cref="T:System.EnterpriseServices.TransactionOption">TransactionOption</see> 은 <b>Disabled</b>
            이며 파생 클래스에서 재정의 할 수 있다.
            <br/><br/>
            이 클래스가 제공하는 WriteLog 메서드 및 WriteLogIf 메서드는 파일에 로그를 남긴다. 이 메서드들은
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 사용하며 로그 파일의 이름은
            컴포넌트 클래스의 이름이다. 예를 들어, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스에서 파생된 Component1 클래스가 있고
            이 클래스에서 WriteLog 메서드 호출을 수행하면 Component1_yyMMdd.log 파일에 기록이 남게 된다.
            로그 파일이 생성되는 디렉토리 및 로깅 레벨에 대한 사항은 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의
            도움말을 참고하도록 한다.
            <br/><br/>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스의 <see cref="P:TheOne.EnterpriseServices.ComponentBase.EventLog">EventLog</see> 속성은 이벤트 로깅 기능을 지원한다.
            <see cref="P:TheOne.EnterpriseServices.ComponentBase.EventLog"/> 속성은 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의 인스턴스를 반환하며
            이벤트 로그에 기록을 남길 수 있도록 해준다. 이벤트 로그에 기록되는 메시지의 이벤트 소스 이름은 클래스의 이름이다.
            <br/><br/>
            이 클래스는 Activation 와 Deactivation 사이에 소요된 시간을 측정하는 기능을 제공한다. 이 기능을 
            활성화 하기 위해서는 생성자에서 <see cref="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterEnabled">PerfCounterEnabled</see> 속성을
            <b>true</b>로 설정한다. 이렇게 설정함으로써 컴포넌트가 활성화(activate)되고 메서드가 호출된 후
            비활성화(deactivate)될 때까지 소요된 시간을 알아낼 수 있다. 소요된 시간은
            <see cref="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterMode">PerfCounterMode</see> 속성이 지시하는 형태로 기록된다.
            <see cref="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterMode">PerfCounterMode</see> 속성의 기본값은 <see cref="F:TheOne.Diagnostics.PerfCounterMode.SimpleCounter">PerfCounterMode.SimpleCounter</see>로서
            파일에 기록을 남기는 것이다.
            <br/><br/>
            </remarks>
            <example>
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
                    // Simple File logging
                    base.WriteLog("DoSomething() invoked !!!");
                    // Event logging
                    base.EventLog.Write("DoSomething() invoked !!!");
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.#cctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스의 새 인스턴스를 정적으로 초기화 한다.  
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스 및 파생 클래스들에 대한 정적 생성자로서 1회만 수행된다.<br/>
            NeoDEEX 구성파일 또는 Configuration 에서 설정들을 읽고 초기화를 한다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.#ctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스에서 파생된 클래스는 기본 생성자를 정의하여 성능 카운트 설정을
            변경할 수 있다. <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스는 기본적으로 성능 카운트가 비 활성화가 되어 있으므로
            기본 생성자에서 <see cref="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterEnabled">PerfCounterEnabled</see> 속성의 값을
            <b>true</b> 로 설정하여 성능 카운트 기능을 활성화 시킬 수 있다.
            </remarks>
            <example>
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                // 이하 생략
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.Activate">
             <summary>
             COM+ 컴포넌트가 활성화(activate)되었음을 알리는 메서드이다.
             </summary>
             <remarks>
             COM+ 컴포넌트가 활성화(activate) 되면 호출되는 메서드로서 성능 카운트의 시작점이다.
             <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
             Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는
             성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
             소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
             <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
             측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
             카운터에 기록하도록 한다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스에서 파생된 클래스가 Activate() 메서드를 재정의 하는 경우,
             반드시 기본 클래스의 Activate() 메서드를 호출해야 한다. 만약 기본 클래스의 Activate()
             메서드를 호출하지 않는 경우, 성능 카운트 기능은 작동하지 않는다.
             </remarks>
             <example>
             <code>
             [System.Runtime.InteropServices.ComVisible(true)]
             public class Component1 : TheOne.EnterpriseServices.ComponentBase
             {
            		protected override void Activate()
            		{
            			// invoke base implementation
            			base.Activate ();
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Activated...");
            		}
            
            		protected override void Deactivate()
            		{
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Deactivated...");
            			// invoke base implementation
            			base.Deactivate ();
            		}
            		
                 // 이하 생략
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.Deactivate">
             <summary>
             COM+ 컴포넌트가 비활성화(deactivate)되었음을 알리는 메서드이다.
             </summary>
             <remarks>
             COM+ 컴포넌트가 비활성화(deactivate) 되면 호출되는 메서드로서 성능 카운트의 끝점이다.
             <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
             Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는
             성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
             소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
             <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
             측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
             카운터에 기록하도록 한다.
             </remarks>
             <example>
             <code>
             [System.Runtime.InteropServices.ComVisible(true)]
             public class Component1 : TheOne.EnterpriseServices.ComponentBase
             {
            		protected override void Activate()
            		{
            			// invoke base implementation
            			base.Activate ();
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Activated...");
            		}
            
            		protected override void Deactivate()
            		{
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Deactivated...");
            			// invoke base implementation
            			base.Deactivate ();
            		}
            		
                 // 이하 생략
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.WriteLog(System.String,System.Object[])">
            <summary>
            로그 파일에 메시지를 기록한다.
            </summary>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.<br/>
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.WriteLog(TheOne.Diagnostics.LogLevel,System.String,System.Object[])">
            <summary>
            지정된 로그 레벨로 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="level">로그 레벨</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.WriteLogIf(System.Boolean,System.String,System.Object[])">
            <summary>
            지정된 조건을 만족하면 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="expr">조건식</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.WriteLogIf(System.Boolean,TheOne.Diagnostics.LogLevel,System.String,System.Object[])">
            <summary>
            지정된 조건을 만족하면 지정된 로그 레벨로 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="expr">조건식</param>
            <param name="level">로그 레벨</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.ComponentBase.ExceptionHandler(System.Exception)">
            <summary>
            COM+ 컴포넌트의 사용자 정의 예외(exception) 처리 핸들러이다.
            </summary>
            <param name="ex">처리할 예외(exception) 객체</param>
            <returns>클라이언트 혹은 컴포넌트를 호출한 다른 컴포넌트에게 throw 할 예외 객체를 반환한다.</returns>
            <remarks>
            컴포넌트의 메서드 처리에서 발생하는 예외를 처리하는 공통 예외 처리 메서드이다.
            표준 구현은 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해
            컴포넌트 로깅 파일에 Error 로그를 남긴다.
            <br/><br/>
            ComponentBase 클래스에서 파생된 클래스는 ExceptionHandler의 기본 구현을 사용하거나
            ExceptionHandler 메서드를 재정의하여 사용해야 한다. 권장되는 사용 방법은
            프로젝트 레벨의 기본 클래스에서 이 메서드를 재정의 하여 프로젝트 레벨의 표준 예외
            처리를 따르는 것이 좋다.
            <br/><br/>
            </remarks>
            <example>
            다음 코드는 ExceptionHandler의 기본 구현을 사용하는 예제 코드이다.
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
            		try {
            			// do your own task...
            		}
            		catch(Exception ex) {
            			ExceptoinHandler(ex);
            			throw;					// rethrow exception
            		}
                }
            }
            </code>
            다음 코드는 ExceptionHandler를 재정의하는 예제 코드이다.
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
            	protected virtual Exception ExceptionHandler(Exception ex)
            	{
            		// 기술적 오류메시지를 감추고 사용자 친화적 메시지와 코드를 설정한다.
            		TheOneException newEx = new TheOneException("비즈니스 로직 오류 입니다.", base.ExceptionHandler());
            		newEx.Code = -9010;
            		return newEx;
            	}
            	
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
            		try {
            			// do your own task...
            		}
            		catch(Exception ex) {
            			ex = ExceptoinHandler(ex);
            			throw ex;
            		}
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.EventLog">
            <summary>
            이벤트 로그 기록을 위한 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의
            새 인스턴스를 초기화 한다.
            </summary>
            <remarks>
            EventLog 속성이 반환하는 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의
            인스턴스는 컴포넌트 이름을 이벤트 소스 이름으로 하는 이벤트 로그 메시지를 기록하도록 해준다.
            </remarks>
            <example>
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
                    // Simple File logging
                    base.WriteLog("DoSomething() invoked !!!");
                    // Event logging
                    base.EventLog.Write("DoSomething() invoked !!!");
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterEnabled">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운트 기능의 활성화 상태를 가져오거나 설정한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
            Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는
            성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
            소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
            <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
            측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
            카운터에 기록하도록 한다.
            </remarks>
            <example>
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.PerfCounterMode">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운팅의 모드를 가져오거나 설정한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
            Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.EnterpriseServices.ComponentBase"/> 클래스가 제공하는
            성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
            소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
            <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
            측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
            카운터에 기록하도록 한다.
            <br/><br/>
            성능 카운트 모드는 SimpleCounter와 SystemCounter 모드 두 종류를 지원한다.
            SimpleCounter는 단순히 파일에 Activate 부터 Deactivate 까지 소요된 시간을 기록한다.
            반면 SystemCounter는 Windows의 성능 카운터 기능을 이용하여 현재 활성화된 컴포넌트의
            개수, 초당 활성화된 컴포넌트의 개수, 활성화당 평균 소요시간 등의 상세한 정보를
            제공한다.
            <para>기본값은 SimpleCounter 이다.</para>
            </remarks>
            <example>
            <code>
            [System.Runtime.InteropServices.ComVisible(true)]
            public class Component1 : TheOne.EnterpriseServices.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                    // Seeting counter mode
                    base.PerfCounterMode = PerfCounterMode.SystemCounter;
                }
                
                [System.EnterpriseServices.AutoComplete]
                public void DoSomething()
                {
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.PerfLogTreshold">
            <summary>
            성능 카운터 로그를 기록여부를 결정하는 기준 카운터 값을 가져오거나 설정한다.
            </summary>
            <remarks>
            PerfCounterMode 속성이 Basic 혹은 Both 인 경우, 컴포넌트의 수행 시간을 나타나는
            성능 카운터 로그가 파일에 기록된다. 이 때, PerfLogThreshold 속성이 지정하는 값을
            초과하는 수행 시간에 대해서만 성능 카운터 로그가 기록되게 된다.<br/>
            예를 들어, 어떤 컴포넌트의 수행시간이 1200msec 일 때, PrefLogThreshold 속성 값이
            1500msec(기본값)이면 로그가 기록되지 않고, 1000msec 이라면 로그가 기록된다.<br/><br/>
            이 속성의 기본값은 1500msec 이며, configuration을 통해 설정할 수 있다.
            configuration 을 통한 설정은 전역 기본 값이며, 각 컴포넌트 별로 생성자에서
            이 속성의 값을 컴포넌트 별로 다른 값으로 설정할 수도 있다.<br/><br/>
            <b>주의) 이 속성은 Windows의 성능 카운터 기록과는 무관하다.</b>
            </remarks>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.ForcePerfLog">
            <summary>
            성능 카운터 로깅을 PerfLogThreshold에 무관하게 수행할 수 있는 상태를 가져오거나 설정한다.
            </summary>
            <remarks>
            이 속성의 값이 <b>true</b> 이면 성능 카운터 로깅을 무조건 수행한다. 즉, PrefLogThrehold 설정을
            무시하고 컴포넌트가 수행한 시간을 로그 파일에 기록하게 된다.<br/>
            이 속성은 기본적으로 예외가 발생하여 ExceptionHandler 메서드가 호출되는 경우에
            자동으로 <b>true</b>로 설정된다.<br/>
            예외 발생과 무관하게 PrefLogThreshold 설정을 무시하고자 하는 경우, 컴포넌트의 생성자에
            이 속성의 값을 <b>true</b>로 설정하면 된다.<br/><br/>
            <b>주의 1) 이 속성은 Windows 성능 카운터 기록과는 무관하다.<br/>
            주의 2) PerfCounterEnabled 속성이 <b>false</b> 이면 이 속성의 값에 무관하게 기록은 남지 않는다.
            </b>
            </remarks>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.UserID">
            <summary>
            컴포넌트를 호출한 사용자의 ID를 가져온다.
            </summary>
            <remarks>
            UserID 속성을 통해 사용자 ID가 설정되기 위해서 클라이언트는
            <see cref="T:TheOne.Security.UserInfoContext">UserInfoContext</see> 클래스의 인스턴스를
            생성하고 이 클래스의 <see cref="M:TheOne.Security.UserInfoContext.SetThreadPrincipal">SetCallContext</see>
            메서드를 해당 쓰레드에 대해 호출해 주어야 한다.
            <br/><br/>
            </remarks>
            <example>
            클라이언트 코드 예제
            <code>
            TheOne.Security.UserInfoContext ctx = new TheOne.Security.UserInfoContext("User1");
            ctx.SetCallContext();
            
            using(MyComp obj = new MyComp) {
               obj.DoIt();
            }
            </code>
            컴포넌트 코드 예제
            <code>
            public class MyComp : ComponentBase
            {
            	public void DoIt()
            	{
            		WriteLog("UserID = {0}", this.UserID);	// 출력은 User1 이 될 것이다.
            	}
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.ComponentBase.UserInfo">
             <summary>
             컴포넌트를 호출한 사용자 정보를 담는 UserInfoContext 객체를 가져온다.
             </summary>
             <remarks>
             UserID 속성을 통해 사용자 ID가 설정되기 위해서 클라이언트는
             <see cref="T:TheOne.Security.UserInfoContext">UserInfoContext</see> 클래스의 인스턴스를
             생성하고 이 클래스의 <see cref="M:TheOne.Security.UserInfoContext.SetThreadPrincipal">SetCallContext</see>
             메서드를 해당 쓰레드에 대해 호출해 주어야 한다.
             <br/><br/>
             UserInfoContext 객체는 UserID 만을 담고 있기 때문에 추가적인 정보를 담기 위해서는
             UserInfoContext에서 상속받은 사용자 정의 사용자 정보 객체를 만들어야 한다. 다음 예제 코드는
             구체적인 방법을 보여주고 있다. 주의할 점은 상속 받은 MyUserInfoContext 객체는 반드시
             Serializable 특성(attribute)를 가져야 한다는 것이다.
             </remarks>
             <example>
             클라이언트 코드 예제
             <code>
             MyUserInfoContext ctx = new MyUserInfoContext("User1", "Dept #1");
             ctx.SetCallContext();
             
             using(MyComp obj = new MyComp) {
                obj.DoIt();
             }
             </code>
             컴포넌트 코드 예제
             <code>
             public class MyComp : ComponentBase
             {
            		// typed 액세스를 위해 UserInfo 속성을 재정의.
            		protected new MyUserInfoContext UserInfo
            		{
             		get { 
             			return (MyUserInfoContext)base.UserInfo;
             		}
            		}
            
            		public void DoIt()
            		{
            			WriteLog("UserID = {0}, Dept = {1}", this.UserID, this.UserInfo.DeptID);	// 출력은 User1, Dept #1 이 될 것이다.
            		}
             }
             
             [Serializable]
            	public class MyUserInfoContext : TheOne.Security.UserInfoContext
             {
             	private string _DeptID;
             
             	public MyUserInfoContext(string userID, string deptID) : base(userID) {
             		_DeptID = deptID;
             	}
             
             	public string DeptID {
             		get { return _DeptID; }
             	}
             }
             </code>
             </example>
        </member>
        <member name="F:TheOne.EnterpriseServices.DbObjectBase._DbAccess">
            <summary>
            DbObjectBase 클래스에서 사용하는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의
            인스턴스
            </summary>
            <remarks>
            DbAccess 클래스는 추상 클래스이므로 실제 인스턴스는 DbAccess에서 파생된
            SqlDbAccess 혹은 OleDbAccess 등의 인스턴스이다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.DbObjectBase.#ctor">
             <summary>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스의 새 인스턴스를 초기화 한다. 
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/>의 기본 생성자에서 <see cref="M:TheOne.EnterpriseServices.DbObjectBase.CreateDbInstance">CreateDbInstance</see> 메서드를
             호출하여 이 클래스가 사용할 DbAccess 객체를 내부적으로 유지한다. 또한 
             <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 기본값은 <b>false</b>로 설정한다.
             <br/><br/>
             OpenOnActivate 속성의 기본 설정인 <b>false</b>를 바꾸기 위해서는 이 클래스에서 파생된 클래스는
             생성자에서 OpenOnActivate 속성 값을 변경하여야 한다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Supported)]
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		// Close() method will be called automatically
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DbObjectBase.Activate">
             <summary>
             컴포넌트가 활성화 되었음 알리는 메서드이다. <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/>  클래스는 연관된
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see>의 데이터베이스 연결을 연다. 
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가 <see cref="M:System.EnterpriseServices.ServicedComponent.Activate">Activate</see> 될 때
             연결 할 수 있으며 <see cref="M:System.EnterpriseServices.ServicedComponent.Deactivate">Deactivate</see> 될 때
             연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/>에서 파생된 클래스가 Activate를 재정의 하는 경우, 반드시
             기본 클래스의 <b>base.Activate()</b> 를 호출해 주어야 한다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	protected override void Activate() {
             		// you must call Activate() method of base class
             		base.Activate();
             		this.EventLog.Write("Activated...");
             	}
            
             	protected override void Deactivate() {
             		// you must call Deactivate() method of base class
             		this.EventLog.Write("Deactivated...");
             		base.Deactivate();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DbObjectBase.Deactivate">
             <summary>
             컴포넌트가 비활성화 되었음 알리는 메서드이다. DbObjectBase 클래스는 연관된
             DbAccess의 데이터베이스 연결을 닫는다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가 <see cref="M:System.EnterpriseServices.ServicedComponent.Activate">Activate</see> 될 때
             연결 할 수 있으며 <see cref="M:System.EnterpriseServices.ServicedComponent.Deactivate">Deactivate</see> 될 때
             연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             DbObjectBase에서 파생된 클래스가 Deactivate를 재정의 하는 경우, 반드시
             기본 클래스의 <b>base.Deactivate()</b>를 호출해 주어야 한다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	protected override void Activate() {
             		// you must call Activate() method of base class
             		base.Activate();
             		this.EventLog.Write("Activated...");
             	}
            
             	protected override void Deactivate() {
             		// you must call Deactivate() method of base class
             		this.EventLog.Write("Deactivated...");
             		base.Deactivate();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess.Open() is already called
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DbObjectBase.CreateDbInstance">
             <summary>
             데이터 컴포넌트(DbObjectBase 클래스에서 파생된 클래스)에서 사용할
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스에서 파생된 COM+ 컴포넌트에서 사용할 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 객체를
             생성한다. 이 메서드를 재정의함으로써 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 객체를 생성할 수 있고
              <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 객체에 연결문자열을 설정하는 등의 초기화 작업을 수행한다.
             이 메서드에서 생성한  <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 객체는 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess">DbAccess</see> 속성을
             통해 액세스 할 수 있다.
             <br/><br/>
             CreateDbInstance 메서드는 <b>abstract</b> 메서드이므로 DbObjectBase 클래스에서 파생된
             모든 클래스는 이 메서드를 재정의 해야만 한다. DbObjectBase에서 파생된
             <see cref="T:TheOne.EnterpriseServices.DACBase">DACBase</see> 클래스는 이 메서드의 구현에서
             SqlDbAccess 클래스의 인스턴스를 생성하여 반환한다.
             SQL Server를 액세스하는 COM+ 컴포넌트는 DACBase에서 파생시키고
             다른 OLEDB 기반의 데이터베이스를 액세스하는 COM+ 컴포넌트가 필요하다면 OleDbObjectBase 를
             정의하고 이 클래스의 CreateDbInstance() 메서드에서 OleDbAccess 클래스의 인스턴스를 생성하여 반환하도록 한 후,
             컴포넌트들이 OleDbObjectBase 클래스에서 파생함으로써 CreateDbInstace() 메서드의 구현을 모든
             COM+ 컴포넌트가 수행해야 할 필요가 없도록 할 수 있다.
             </remarks>
             <returns>
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see>를 반환한다.
             </returns>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;		// override default
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// Setting hard-coded connection string.
             		// It is not recommanded to use hard-coded connection string.
             		// Using .config file and appSettings section, you can avoid hard-coded
             		// connection string.
             		// However, sometimes it is required to connect unusual data source,
             		// which is not a default data source.
             		// In such case, override CreateDbInstace() method for the unusal connection string.
             		return new SqlDbAccess("server=mydbserver;uid=sa;pwd=");
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess.Open() is already called.
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">
             <summary>
             컴포넌트가 Activate 와 Deactivate 될 때 데이터베이스 연결을 열고 닫을 수 있는 상태를 가져오거나 설정한다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가 <see cref="M:System.EnterpriseServices.ServicedComponent.Activate">Activate</see> 될 때
             연결 할 수 있으며 <see cref="M:System.EnterpriseServices.ServicedComponent.Deactivate">Deactivate</see> 될 때
             연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             이 행동에 대한 설정은 OpenOnActivate 속성을 통해 실행한다. 이 속성이
             <b>true</b> 이면 Activate 또는 Deactivate에서 데이터베이스 연결을 열고 닫지만
             <b>false</b> 이면 이러한 데이터베이스 연결 작업을 <b>public</b> 메서드 내에서 수동으로 실행해야 한다.
             기본값은 <b>false</b> 이다.
             <br/><br/>
             OpenOnActivate 속성의 설정은 생성자에서만 효과를 나타낸다. 다른 메서드에서의 설정은
             효과를 나타내지 않는다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		// Close() method will be called automatically
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="P:TheOne.EnterpriseServices.DbObjectBase.DbAccess">
             <summary>
             데이터 컴포넌트에서 사용하는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DbObjectBase"/> 클래스 (혹은 그 파생 클래스)는 데이터 컴포넌트가 사용하는
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스 혹은 그 파생 클래스의 인스턴스를
             가지고 있다. 이 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체는 <see cref="M:TheOne.EnterpriseServices.DbObjectBase.CreateDbInstance">CreateDbInstance</see> 메서드에서
             생성한 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이며 이 객체를 통해 데이터베이스를 액세스 할 수 있다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.#ctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
            <remarks>
            DACBase 클래스는 DbAccess 객체로서 SqlDbAccess 객체를 사용한다.
            즉, <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 속성는 SqlDbAccess 클래스의
            인스턴스이다. 따라서 이 클래스에서 파생된 클래스의 메서드들에서
            DbAccess 속성를 통해 데이터베이스를 액세스하는 경우 SQL Server를 사용하게
            되는 것이다.
            <br/><br/>
            <see cref="P:TheOne.EnterpriseServices.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 기본 설정인 <b>false</b>를 바꾸기 
            위해서는 이 클래스에서 파생된 클래스는 생성자에서 OpenOnActivate 속성 값을 바꾸어야 한다.
            </remarks>
            <example>
            <code>
            public class DbComponent1 : DACBase
            {
            	public void DbComponent1() {
            		this.OpenOnActivate = true;	// overriding default beavior
            	}
            	
            	[AutoComplete]
            	public DataSet GetData() {
            		DataSet ds = new DataSet();
            		
            		// Open() method was already called automatically.
            		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
            		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
            		
            		// Close() method will be called automatically
            		return ds;
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.CreateDbInstance">
             <summary>
              <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를 생성하여
             반환 함으로써 <see cref="T:TheOne.EnterpriseServices.DACBase"/>에서 파생된 클래스의 메서드들이 데이타베이스를 액세스
             할 수 있도록 한다.
             </summary>
             <remarks>
             <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스의 CreateDbInstance() 구현은 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를
             생성하여 반환하는 것이다. 생성된 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스는 NeoDEEX 구성 파일의
             <b>databaseSection</b> 에서 <b>defaultDatabase</b> 의 속성값을 사용하여 초기화 된다.
             따라서 반드시 NeoDEEX 구성 파일의 <b>databaseSection</b>에 <b>defaultDatabase</b> 값에
             접속하고자 하는 기본 데이타베이스 연결문자열 컬렉션의 이름이 설정되어야 한다.
             <br/><br/>
             만약 특정 데이터 액세스 컴포넌트가 <b>defaultDatabase</b>의 값을 사용하지 않고
             제2, 제3의 데이터베이스에 접속한다면 CreateDbInstance() 메서드를 재정의하여
             다른 연결 문자열을 사용하도록 해야 한다.
             </remarks>
             <returns>
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를 반환한다.
             </returns>
             <example>
             SQL Server를 액세스하는 데이터 액세스 컴포넌트를 파생하여
             다음과 같이 작성한다.
             <code>
             public class DbComponent2 : DACBase
             {
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             어플리케이션의 대부분 데이터 액세스 컴포넌트가 이와 같이
             작동하지만 일부 예외적으로 다른 DB에 접근해야 하는 데이터 액세스 컴포넌트가 존재한다면
             CreateDbInstance 메서드를 재정의하여 별도의 연결문자열을 지정해 줄 수 있다.
             <code>
             public class DbComponent3 : DACBase
             {
                 protected override DbAccess CreateDbInstance()
                 {
             		return new SqlDbAccess("server=server2;uid=user2;pwd=pwd2");
                 }
                 
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             위 코드에서 DbComponent2는 NeoDEEX 구성의 연결문자열을 사용하지만 DbComponent3는
             직접 연결 문자열을 지정함으로써 기본값으로 정이된 데이타베이스가 아닌 다른 데이타베이스에 접속한다.
             </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Save(System.Data.DataSet)">
            <summary>
            지정된 <see cref="T:System.Data.DataSet"/>에서 변경 사항(<b>Insert, Update, Delete</b>)을 커밋한다.
            </summary>
            <param name="ds">저장할 <see cref="T:System.Data.DataSet"/></param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Save(System.Data.DataTable)">
            <summary>
            지정된 <see cref="T:System.Data.DataTable"/>에서 변경 사항(<b>Insert, Update, Delete</b>)을 커밋한다.
            </summary>
            <param name="dt">저장할 <see cref="T:System.Data.DataTable"/></param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.SaveInternal(System.Data.DataTable)">
            <summary>
            <see cref="T:System.Data.DataRowState"/>를 기준으로 필터링된 내용이 모두 들어 있는  <see cref="T:System.Data.DataTable"/>의 복사본을 가져와서
            데이터테이블에 변경된 내용들을 커밋한다.
            레코드 변경 사항에 따라 <b>Insert, Update, Delete</b>가 호출된다.
            </summary>
            <remarks>
            저장 순서는 <b>Insert, Update, Delete</b> 이다. 즉, 모든 <b>Insert</b> 후에
            <b>Update, Delete</b>가 수행된다.
            </remarks>
            <param name="dt">커밋할 데이터 테이블</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Insert(System.Data.DataRowCollection)">
            <summary>
            Insert를 수행할 Row들에 대해 InsertRow 메서드를 호출한다.
            </summary>
            <param name="rows">추가되어야 하는 <see cref="T:System.Data.DataRowCollection"/> 객체</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Delete(System.Data.DataRowCollection)">
            <summary>
            Delete를 수행할 Row들에 대해 DeleteRow 메서드를 호출한다.
            </summary>
            <param name="rows">삭제가 될 <see cref="T:System.Data.DataRowCollection"/> 객체</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Update(System.Data.DataRowCollection)">
            <summary>
            Update를 수행할 Row들에 대해 UpdateRow 메서드를 호출한다.
            </summary>
            <param name="rows">업데이트가 될 <see cref="T:System.Data.DataRowCollection"/> 객체</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Select(System.Object[])">
            <summary>
            지정된 인수를 사용하여 데이타를 검색한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스의 Select 메서드는 아무런 작업도 수행하지 않고
            null을 반환한다. 이 메서드를 재정의하면 DataSet 객체
            (typed 혹은 untyped)를 생성하고 조회를 수행하고 그 결과를 DataSet
            객체에 Fill 한 후 DataSet을 반환한다.
            </remarks>
            <example>
            public override DataSet Select(params object[] param)
            {
            	DataSet ds = new DataSet();
            	// this.DbAccess 를 통한 데이터 액세스 및 DataSet 채우기(fill) 수행.
            	// 매개변수는 매개변수 배열을 통해 사용한다.
               return ds;
            }
            </example>
            <param name="param">Paramter 배열</param>
            <returns>DataSet을 반환한다.</returns>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.Select(System.Data.IDataParameterCollection)">
            <summary>
            지정된 Command개체 매개변수를 사용하여 데이타를 검색한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.DACBase"/> 클래스의 Select 메서드는 아무런 작업도 수행하지 않고
            null을 반환한다. 이 메서드를 재정의하면 DataSet 객체
            (typed 혹은 untyped)를 생성하고 조회를 수행하고 그 결과를 DataSet
            에 행을 추가하고 DataSet을 반환한다.
            </remarks>
            <example>
            public override DataSet Select(ParameterSet ps)
            {
            	DataSet ds = new DataSet();
            	// this.DbAccess 를 통한 데이터 액세스 및 DataSet 채우기(fill) 수행.
            	// 매개변수는 ParameterSet 객체를 통해 사용한다.
               return ds;
            }
            </example>
            <param name="parameters">IDataParameterCollection 객체</param>
            <returns></returns>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.InsertRow(System.Data.DataRow)">
            <summary>
            <see cref="T:System.Data.DataRowCollection"/>에 추가된 Row에 대하여 Insert작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Added"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            데이터셋 내의 여러 테이블의 Insert된 행에 대해 InsertRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">삽입시킬 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.DeleteRow(System.Data.DataRow)">
            <summary>
            DataTable에서 삭제된 Row에 대하여 Delete 작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Deleted"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            <see cref="T:System.Data.DataSet"/> 안의 여러 테이블의 Delete된 행에 대해 DeleteRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">삭제가 되어질 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="M:TheOne.EnterpriseServices.DACBase.UpdateRow(System.Data.DataRow)">
            <summary>
            DataTable의 수정된 Row에 대하여 Update작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Modified"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            <see cref="T:System.Data.DataSet"/> 안의 여러 테이블의 Update된 행에 대해 UpdateRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">업데이트가 되어질 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="T:TheOne.EnterpriseServices.BIZBase">
            <summary>
            COM+ 서비스를 사용하는 비즈니스 로직 컴포넌트의 기본 클래스를 정의한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.EnterpriseServices.BIZBase"/> 클래스는 비즈니스 로직 컴포넌트에 대한 기본 클래스로 사용된다.
            비록 <see cref="T:TheOne.EnterpriseServices.DbObjectBase">DbObjectBase</see> 클래스처럼 데이터베이스
            연결을 관리하는 등의 특별한 기능을 가지고 있지 않지만 단일 클래스에서 파생되도록
            하여 일관된 클래스 계층 구조를 갖도록 할 수 있다.<br/>
            <see cref="T:TheOne.EnterpriseServices.BIZBase"/> 클래스가 독자적인 기능을 갖고 있지 않지만
            <see cref="T:TheOne.EnterpriseServices.ComponentBase">ComponentBase</see> 클래스에서 파생되었으므로
            ComponentBase 클래스가 갖는 파일 로깅, 이벤트 로깅, 성능 측정 기능 등은 여전히 사용할 수
            있다.
            <br/><br/>
            <see cref="T:TheOne.EnterpriseServices.BIZBase"/> 클래스에 선언된 COM+ 관련 특성(attribute)은 이 클래스의 기본 클래스인
            <see cref="T:TheOne.EnterpriseServices.ComponentBase">ComponentBase</see> 클래스의 특성(attribute)을 상속
            받는다. 다만, Transaction 특성(attribute)의 기본값은 <b>Required</b>
            로 설정되어 있다. 대개의 비즈니스 로직 컴포넌트가 <b>Required</b>설정을 갖기 때문이다.<br/>
            이 클래스에서 파생된 클래스가 명시적으로 Transaction 특성(attribute)을 지정하지 않는다면 트랜잭션 속성은 <b>Required</b>가 된다.
            또한 Transaction Isolation Level의 기본값은 <b>ReadCommitted</b>을 사용한다.
            </remarks>
            <example>
            <code>
            // NOTE :: default transaction option is 'Required' 
            // [Transaction(TransactionOption.Required, IsolationLevel = TransactionIsolationLevel.ReadCommitted)]
            public class BizComponent1 : BIZBase
            {
            	[AutoComplete]
            	public int DoBizLogic()
            	{
            		// Write your biz logic code...
            		// In this simple example, just invoke data access component which is derived from
            		// DbObjectBase class.
            		DbComponent obj = new DbComponent();
            		try {
            			DataSet ds = obj.GetData();
            			return ds.Tables[0].Rows.Count;
            		}
            		finally {
            			obj.Dispose();
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.EnterpriseServices.BIZBase.#ctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.BIZBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
        </member>
        <member name="T:TheOne.EnterpriseServices.Resources.Default">
            <summary>
              지역화된 문자열 등을 찾기 위한 강력한 형식의 리소스 클래스입니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.ResourceManager">
            <summary>
              이 클래스에서 사용하는 캐시된 ResourceManager 인스턴스를 반환합니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.Culture">
            <summary>
              이 강력한 형식의 리소스 클래스를 사용하여 모든 리소스 조회에 대한 현재 스레드의 CurrentUICulture
              속성을 재정의합니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.ComponentBase_ComponentBase_1">
            <summary>
              유효하지 않은 전역 로깅 카운터 기준값({0})이 사용되어 디폴트 값({1})을 사용합니다.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.PerfCounterMgr_EnsureCounterExists_1">
            <summary>
              COM+ 성능 카운터가 존재하지 않아 새로이 생성합니다.과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.PerfCounterMgr_Init_1">
            <summary>
              성능 카운터를 초기화 할 수 없습니다. 카운터가 존재하지 않거나 생성에 실패했습니다. 오류로 인해 성능 카운터가 Disable 됩니다. 상세한 오류 정보는 다음과 같습니다.\r\n\r\n{0}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.PerfCounterMgr_OnActivate_1">
            <summary>
              Activated :: COM+ 성능 카운터를 기록하는 도중 오류가 발생되었습니다. 성능 카운터를 Disable 합니다. 상세한 오류메시지는 다음과 같습니다.\r\n\r\n{0}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="P:TheOne.EnterpriseServices.Resources.Default.PerfCounterMgr_OnDeactivate_1">
            <summary>
              Deactivated :: COM+ 성능 카운터를 기록하는 도중 오류가 발생되었습니다. 성능 카운터를 Disable 합니다. 상세한 오류메시지는 다음과 같습니다.\r\n\r\n{0}과(와) 유사한 지역화된 문자열을 찾습니다.
            </summary>
        </member>
        <member name="T:TheOne.EnterpriseServices.PerfCounterMgr">
            <summary>
            COM+ 컴포넌트의 성능 카운터(Performance Counter)를 처리하는 클래스이다.<br/> 
            이 클래스는 NeoDEEX 내부에서만 사용하는 클래스이다.
            </summary>
            <remarks>
            COM+ 컴포넌트의 성능 카운터는 다음과 같은 정보를 제공한다.<br/>
            <li>
            	<ul>현재 활성화되어 수행되고 있는 컴포넌트의 개수</ul>
            	<ul>초당 수행되는 컴포넌트의 개수</ul>
            	<ul>컴포넌트가 수행되는 평균 수행 시간</ul>
            </li>
            <br/>
            COM+ 성능 카운터는 프로세스에 관계없이 전체 시스템에 대한 카운터 값과
            각 시스템마다 카운터 값을 제공한다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.PerfCounterMgr.#cctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.PerfCounterMgr"/> 클래스의 새 인스턴스를 정적으로 초기화 한다
            </summary>
        </member>
        <member name="M:TheOne.EnterpriseServices.PerfCounterMgr.Init(System.Boolean)">
            <summary>
            성능 카운터를 초기화하며 필요한 경우 새로운 성능카운터 인스턴스를 만들어 초기화한다.
            </summary>
            <param name="install">설치에 의해 초기화 되었는가 여부</param>
            <returns>성능카운터의 초기화 성공 여부를 반환한다.</returns>
        </member>
        <member name="M:TheOne.EnterpriseServices.PerfCounterMgr.ResetAllCounterValue">
            <summary>
            COM+ 관련 성능 카운터들을 모두 초기화 한다.
            </summary>
        </member>
        <member name="T:TheOne.EnterpriseServices.PerfCounterInstaller">
            <summary>
            COM+ 성능 카운터 설치 클래스이다.
            </summary>
            <remarks>
            COM+ 성능 카운터를 설치한다. 이 클래스는 installutil.exe 프로그램에 의해
            성능카운터가 설치될 때 사용되는 클래스로서 개발자는 사용하지 않는 클래스이다.
            </remarks>
        </member>
        <member name="M:TheOne.EnterpriseServices.PerfCounterInstaller.#ctor">
            <summary>
            <see cref="T:TheOne.EnterpriseServices.PerfCounterInstaller"/> 클래스의 새 인스턴스를 초기화 한다.
            </summary>
        </member>
        <member name="M:TheOne.EnterpriseServices.PerfCounterInstaller.SetupPerformanceCounterInstaller">
            <summary>
            성능 카운터 설치 관련 코드
            </summary>
        </member>
    </members>
</doc>
