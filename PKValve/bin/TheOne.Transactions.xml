<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TheOne.Transactions</name>
    </assembly>
    <members>
        <member name="T:TheOne.Transactions.ExecutionProcessingException">
            <summary>
            트랜잭션 컴포넌트에서 <see cref="T:TheOne.Transactions.Common.ExecutionContext">ExecutionContext</see>를 실행하면서 발생하는 예외를 처리하는 클래스이다.
            </summary>
            <remarks>
            TheOne.Transactions 네임스페이스 내에서 컨텍스트를 제어하거나 트랜잭션을 처리하면서
            발생하는 예외이다. 이 예외 자체가 내용을 가지고 있는 경우도 있지만 대개 내부 예외(inner exception) 정보를
            확인을 하여야 한다. 예를 들어, 트랜잭션이 이미 <b>Abort</b> 되어 있는 상황에서 추가적으로
            트랜잭션을 요구하는 컴포넌트가 호출되면 <see cref="T:System.Transactions.TransactionAbortedException">TransactionAbortedExecption</see>이 유발된다.
            하지만 이 예외가 직접적으로 발생하지 않는다. 대신 <see cref="T:System.ExecutionEngineException">ExecutionEngineExecption</see> 이 발생하고
            이 예외의 내부 예외로써 <see cref="T:System.Transactions.TransactionAbortedException">TransactionAbortedExecption</see>이 포함된다.
            <para>
            <see cref="T:System.ExecutionEngineException">ExecutionEngineExecption</see>은 트랜잭션 처리 과정에서 발생하는 예외만을 포함하며
            컴포넌트 메서드 내에서 발생하는 예외는 포함하지 않는다. 예를 들어 컴포넌트 메서드에서
            데이타 베이스를 액세스할 때 발생할 수 있는 <see cref="T:TheOne.Data.DBException"> DBException</see>은
            <see cref="T:System.ExecutionEngineException">ExecutionEngineExecption</see>을 통하여 발생하지 않는다.
            </para>
            <para>
            이 예외는 프레임워크에 의해서만 발생하므로 개발자가 이 예외를 발생시켜야 하는 경우는 없다.
            다만 개발자는 이 예외를 try~catch 문장에서만 사용하면 된다.
            따라서 이 클래스는 어떤 생성자도 제공하지 않는다.
            </para>
            </remarks>
        </member>
        <member name="T:TheOne.Transactions.DACBase">
             <summary>
             데이터베이스를 액세스하는 트랜잭션 컴포넌트를 위한 추상(abstract) 클래스이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스는 <see cref="T:TheOne.Transactions.DbObjectBase">DbObjectBase</see> 클래스에서
             파생된 클래스로서 데이터베이스를 액세스하는 트랜잭션 컴포넌트를 위한 추상 클래스이다. 
             이 클래스는 <b>abstract</b> 클래스이므로 파생 클래스를 정의해야 하며 
             파생된 클래스는 TheOne.Transactions 데이터 액세스 컴포넌트로서 작동한다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스를 사용하는 권장되는 패턴은 <see cref="T:TheOne.Transactions.DACBase"/> 에서 파생된 프로젝트(과제)만의 기본
             클래스를 작성하고 실제 구체적 업무 클래스는 프로젝트의 기본 클래스에서 파생하는 것이다.
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스는 일반적이고 다양한 용도를 위한 기본값으로 설정이 되어 있기 때문에
             각 프로젝트에서 고유한 기본 설정(연결 문자열, OpenOnActivate 설정 등)으로 변경할 수 있다.
             또한 이 클래스에서 파생된 프로젝트 레벨의 기본 클래스를 생성함으로써 얻을 수 있는 장점은
             추후에 변경될 수 있는 사항을 추가적인 기본 클래스에서 흡수하여 프로젝트 기본 클래스에서 파생하여
             구현된 구체적 업무 클래스들을 수정해야 하는 항목을 줄이는 효과를 얻을 수 있다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스 역시 <see cref="T:TheOne.Transactions.DbObjectBase">DbObjectBase</see> 클래스처럼 컴포넌트가 
             <b>Activate</b> 또는 <b>Deactivate</b> 될때 데이터베이스 연결을 열거나 닫을 수 있다. <br/>
             그리고 이 기본 동작은
             <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성에
             의해 제어할 수 있다. OpenOnActivate 속성의 기본값은 <b>false</b> 이며, 이는 코드 내에서 명시적으로
             Open(), Close() 메서드를 호출해 주거나 DbAccess 클래스의 ExecuteSPxxx, ExecuteSQLxxx 메서드들의 자동 Open/Close
             기능에 의존해야 함을 의미한다. 만약 OpenOnActivate 속성의 값을 생성자에서 <b>true</b> 로 설정하면
             컴포넌트의 메서드가 호출되기 전에 DbAccess 객체의 Open() 메서드는 호출되어 지며 컴포넌트 메서드가 끝나면 Close()가
             호출되어 진다.
             <br/><br/>
             OpenOnActivate를 <b>false</b>로 설정하고 데이터베이스 연결을 수동으로 관리할 때는
             정확하게 Open/Close 시점을 지정할 수 있다는 점에서 효율적인 데이터베이스 연결 관리를 할 수 있다는
             장점이 있지만 Open/Close를 명시적으로 호출하기 위한 try ~ finally 문장을 사용하는 등 프로그래머의
             추가적인 노력이 필요하다는 단점이 있다.<br/>
             반면 OpenOnActivate를 <b>true</b>로 설정하고 데이터베이스 연결을 자동으로 관리하면
             코드 및 로직을 간편하게 가져 갈 수 있으므로 코딩이 보다 쉬워지지만 데이터베이스 연결이
             실제 요구하는 시점보다 조금 일찍 열리고 조금 늦게 닫힌다는 단점이 있다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스의 <see cref="M:TheOne.Transactions.DACBase.CreateDbInstance">CreateDbInstance</see> 메서드 구현은
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를 생성하여 반환하도록
             되어 있다. 즉, <see cref="T:TheOne.Transactions.DACBase"/> 클래스에서 파생된 클래스의 <see cref="T:TheOne.Data.DbAccess">DbAccess</see>
             속성는  <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를 반환하게 된다. 따라서 데이타베이스를 액세스하는 DSL(Data Service Layer)
             컴포넌트들은 <see cref="T:TheOne.Transactions.DACBase"/>를 기본 클래스로 정의함으로써 각 클래스에서 CreateDbInstance 메서드를
             재정의 할 필요가 없게 된다. 만약 DACBase 클래스에서 파생하지 않고 직접
             DbObjectBase 클래스에서 파생된 클래스를 정의한다면 각 파생 클래스들은 CreateDbInstance 메서드를
             반드시 재정의 해야 한다.
             <br/><br/>
             CreateDbInstance 메서드가 생성하는  <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체는 NeoDEEX 구성 파일에서
             연결 문자열을 취하도록 되어 있다. 보다 구체적으로, 연결 문자열은 NeoDEEX 구성 파일의
             appSettings 섹션에서 <b>ConnectionString</b> 키가 지시하는 문자열을 사용한다.
             만약 <see cref="T:TheOne.Transactions.DbObjectBase">DbObjectBase</see> 클래스의 파생 클래스가 이 기본 행동을 바꾸고자 한다면
             CreateDbInstance 메서드를 재정의 하여 다른 연결 문자열을 사용하도록 설정할 수 있다.
             </remarks>
             <example>
             Micorosoft SQL Server 데이타베이스를 액세스하는 어플리케이션의 NeoDEEX 구성 파일에 다음과 같이 연결문자열을 이름/값 쌍으로 추가한다.
             설정한다.
             <code>
             &lt;?xml version="1.0" encoding="utf-8" ?&gt;
             &lt;configuration&gt;
                 &lt;databaseSection defaultDatabase="SqlProvider"&gt;
                     &lt;add name="SqlProvider" type="TheOne.Data.SqlClient.SqlDbAccess"  connectionString="server=(local);Initial Catalog=TEST;uid=user;pwd=123"/&gt;
                 &lt;/databaseSection&gt;
             &lt;/configuration&gt;
             </code>
             SQL Server를 액세스하는 데이터 액세스 컴포넌트를 DACBase에서 파생하여
             다음과 같이 작성한다.
             <code>
             public class DbComponent2 : DACBase
             {
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
            		    // Open/Close method will be invoked in ExecuteSql method implicitly
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             위 코드는 NeoDEEX 구성 파일의 databaseSection에서 defaultDatabase가 지정하는 연결 문자열을 사용하여
             데이터베이스를 액세스한다. 어플리케이션의 대부분 데이터 액세스 컴포넌트가 이와 같이
             작동하지만 일부 예외적으로 다른 DB에 접근해야 하는 데이터 액세스 컴포넌트가 존재한다면
             CreateDbInstance 메서드를 재정의하여 별도의 연결문자열을 지정해 줄 수 있다.
             상세한 예제는 <see cref="M:TheOne.Transactions.DACBase.CreateDbInstance">CreateDbInstance</see> 메서드의 예제를
             참고한다.
             <br/><br/>
             다음 코드는 <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성을 true로 설정하는 예제 코드이다.
             <code>
             public class DbComponent2 : DACBase
             {
             	public void DbComponent2() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		return ds;
             		// Close() method will be called automatically
             	}
             }
             </code>
             </example>
        </member>
        <member name="T:TheOne.Transactions.DbObjectBase">
             <summary>
             데이터 액세스 트랜잭션 컴포넌트(Data Access Component : DAC)를 위한 추상(abstract) 클래스이다.
             </summary>
             <remarks>
             DbObjectBase 클래스는 데이터베이스를 액세스하는 데이터 액세스 컴포넌트를 위한
             추상 클래스로서 이 클래스는 <b>abstract</b> 클래스이므로 파생 클래스를 정의해야 하며 
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를
             속성을 제공하고 데이터베이스 연결에 대하여 열거나 닫는 기능을 자동으로 실행한다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스에서 파생된 구체(concreate) 트랜잭션 컴포넌트 클래스는 <b>public</b> 메서드에서
             <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess">DbAccess</see> 속성을 통해 데이터베이스를 손쉽게 액세스 할 수 있다.
             DbAccess 속성이 지시하는 데이터베이스에 대한 연결은 컴포넌트가 <b>Activate</b> 와 <b>Deactivate</b>될 때
             자동으로 열고 닫히게되므로 개발자가 데이터베이스 연결에 대한 코드를 작성할 필요가 없다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스 혹은 그 파생 클래스에서 DbAccess 속성을 통해 액세스하는 DbAccess 클래스
             혹은 그 파생 클래스의 인스턴스는 <b>abstract</b> 메서드인
             <see cref="M:TheOne.Transactions.DbObjectBase.CreateDbInstance">CrateDbInstance</see>에서 그 인스턴스를 생성하도록 되어 있다.<br/>
             즉, DbAccess 속성이 지시하는 DbAccess 객체는 CreateDbInstace 메서드에서 생성하고 반환한
             객체라는 것이다. 따라서 DbObjectBase 클래스에서 파생된 모든 클래스는 모두 CreateDbInstance 메서드를
             재정의 해야만 한다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스는 컴포넌트가 <b>Activate</b> 또는 <b>Deactivate</b>되는 시점에서 데이터베이스 연결을
             열거나 닫도록 설정할 수 있다. 이 기본 설정을 변경하기 위해서는 파생 클래스의
             생성자에서 <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 값을 <b>true</b>로 설정
             해야 한다. OpenOnActivate의 기본값은 <b>false</b> 이다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스에서 직접 상속을 받고 CreateDbInstance 메서드를 재정의 할 수도 있지만
             이러한 구현이 이미 되어 있는 <see cref="T:TheOne.Transactions.DACBase">DACBase</see> 클래스에서
             데이터 액세스 컴포넌트 클래스를 파생하는 것이 좋다. 이렇게 함으로써 모든 데이터 액세스
             컴포넌트 클래스들이 CreateDbInstance 메서드를 재정의하여 중복 코드를 줄일 수 있다.
             <br/><br/>
             </remarks>
             <example>
             <code>
             // change default transaction option
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return new SqlDbAccess();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		// In this case, it will be SqlDbAccess.
             		DataSet ds = this.DbAccess.ExecuteSqlDataSet("SELECT * FROM tblTest2");
             		return ds;
             	}
             }
             </code>
             </example>    
        </member>
        <member name="T:TheOne.Transactions.ComponentBase">
            <summary>
            Transaction 처리를 실행하는 컴포넌트의 기본 클래스를 정의한다.<br/>
            이 클래스에서 파생된 클래스를 정의함으로써 파일로깅, 이벤트 로깅, 성능 측정 등의
            기능이 기본적으로 제공되는 트랜잭션 컴포넌트를 개발할 수 있다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스는 <b>System.Transactions</b>를 이용하여 선언적인 분산 트랜잭션 문맥 하에서
            닷넷 코드가 수행되도록 해준다. 이는 <b>System.Transactions</b> 네임스페이스의
            <see cref="T:System.Transactions.TransactionScope">TransactionScope</see> 클래스가 제공하는 트랜잭션과 매우 비슷하다.	
            <para>하지만 <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스는 ServicedComponent 클래스와는 달리 COM+ 카탈로그에
            등록하는 과정을 요구하지 않는다. 이 때문에 레지스트리를 액세스하는 등록과정에서
            문제를 유발하지 않는다. 또 한가지 <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스의 장점은 클래스 수준 뿐만 아니라
            메쏘드 수준의 트랜잭션 속성을 지정할 수 있다. ServicedComponent 클래스의 경우,
            클래스 수준에서만 트랜잭션 속성(Required, Supported 등)을 지정할 수 있었다. 이 때문에
            트랜잭션 메쏘드와 비 트랜잭션 메쏘드는 별도의 클래스에 존재해야만 했다. 이러한 제약은
            논리적 클래스 설계와 물리적 클래스 구현이 매우 달라지는 현상을 초래하곤 한다.
            </para>
            <para>
            이 클래스가 제공하는 WriteLog 메서드 및 WriteLogIf 메서드는 파일에 로그를 남긴다. 이 메서드들은
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 사용하며 로그 파일의 이름은
            컴포넌트 클래스의 이름이다. 예를 들어, <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스에서 파생된 Component1 클래스가 있고
            이 클래스에서 WriteLog 메서드 호출을 수행하면 Component1_yyMMdd.log 파일에 기록이 남게 된다.
            로그 파일이 생성되는 디렉토리 및 로깅 레벨에 대한 사항은 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의
            도움말을 참고하도록 한다.
            <br/><br/> 
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스의 <see cref="P:TheOne.Transactions.ComponentBase.EventLog">EventLog</see> 속성은 이벤트 로깅 기능을 지원한다.
            EventLog 속성은 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의 인스턴스를 반환하며
            이벤트 로그에 기록을 남길 수 있도록 해준다. 이벤트 로그에 기록되는 메시지의 이벤트 소스 이름은 클래스의 이름이다.
            <br/><br/>
            이 클래스는 Activation 와 Deactivation 사이에 소요된 시간을 측정하는 기능을 제공한다. 이 기능을
            활성화 하기 위해서는 생성자에서 <see cref="P:TheOne.Transactions.ComponentBase.PerfCounterEnabled">PerfCounterEnabled</see> 속성을
            <b>true</b>로 설정한다. 이렇게 설정함으로써 컴포넌트가 활성화(activate)되고 메서드가 호출된 후
            비활성화(deactivate)될 때까지 소요된 시간을 알아낼 수 있다. 소요된 시간은
            <see cref="P:TheOne.Transactions.ComponentBase.PerfCounterMode">PerfCounterMode</see> 속성이 지시하는 형태로 기록된다.
            PerfCounterMode 속성의 기본값은 <see cref="F:TheOne.Diagnostics.PerfCounterMode.SimpleCounter">PerfCounterMode.SimpleCounter</see>로서
            파일에 기록을 남기는 것이다.
            <br/><br/>
            </para>
            <example>
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                [AutoComplete]
                public void DoSomething()
                {
                    // Simple File logging
                    base.WriteLog("DoSomething() invoked !!!");
                    // Event logging
                    base.EventLog.Write("DoSomething() invoked !!!");
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.#cctor">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스의 새 인스턴스를 정적으로 초기화 한다.  
            </summary>
            <remarks>
            ComponentBase 클래스 및 파생 클래스들에 대한 정적 생성자로서 1회만 수행된다.<br/>
            NeoDEEX 구성파일 또는 Configuration 에서 설정들을 읽고 초기화를 한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.#ctor">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스에서 파생된 클래스는 기본 생성자를 정의하여 성능 카운트 설정을
            변경할 수 있다. <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스는 기본적으로 성능 카운트가 비 활성화가 되어 있으므로
            기본 생성자에서 <see cref="P:TheOne.Transactions.ComponentBase.PerfCounterEnabled">PerfCounterEnabled</see> 속성의 값을
            <b>true</b> 로 설정하여 성능 카운트 기능을 활성화 시킬 수 있다.
            </remarks>
            <example>
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                // 이하 생략
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.Activate">
             <summary>
             트랜잭션 컴포넌트가 활성화(activate)되었음을 알리는 메서드이다.
             </summary>
             <remarks>
             트랜잭션 컴포넌트가 활성화(activate) 되면 호출되는 메서드로서 성능 카운트의 시작점이다.
             <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
             Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는
             성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
             소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
             <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
             측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
             카운터에 기록하도록 한다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스에서 파생된 클래스가 Activate() 메서드를 재정의 하는 경우,
             반드시 베이스 클래스의 Activate() 메서드를 호출해야 한다. 만약 기본 클래스의 Activate()
             메서드를 호출하지 않는 경우, 성능 카운트 기능은 작동하지 않는다.
             </remarks>
             <example>
             <code>
             public class Component1 : TheOne.Transactions.ComponentBase
             {
            		protected override void Activate()
            		{
            			// invoke base implementation
            			base.Activate ();
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Activated...");
            		}
            
            		protected override void Deactivate()
            		{
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Deactivated...");
            			// invoke base implementation
            			base.Deactivate ();
            		}
            		
                 // 이하 생략
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.Deactivate">
             <summary>
             트랜잭션 컴포넌트가 비활성화(deactivate)되었음을 알리는 메서드이다.
             </summary>
             <remarks>
             트랜잭션 컴포넌트가 비활성화(deactivate) 되면 호출되는 메서드로서 성능 카운트의 끝점이다.
             <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
             Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는
             성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
             소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
             <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
             측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
             카운터에 기록하도록 한다.
             </remarks>
             <example>
             <code>
             public class Component1 : TheOne.Transactions.ComponentBase
             {
            		protected override void Activate()
            		{
            			// invoke base implementation
            			base.Activate ();
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Activated...");
            		}
            
            		protected override void Deactivate()
            		{
            			// do your own job
            			base.EventLog.Write(LogLevel.Information, this.GetHashCode(), "Deactivated...");
            			// invoke base implementation
            			base.Deactivate ();
            		}
            		
                 // 이하 생략
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.WriteLog(System.String,System.Object[])">
            <summary>
            로그 파일에 메시지를 기록한다.
            </summary>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.WriteLog(TheOne.Diagnostics.LogLevel,System.String,System.Object[])">
            <summary>
            주어진 로그 레벨로 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="level">로그 레벨</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 FileLogHelper 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 FileLogHelper 클래스를 통해 기록되므로 FileLogHelper 클래스의 DefaultLogLevel, BaseLogLevel 등의
            속성을 그대로 따른다. 따라서 BaseLogLevel 설정과 DefaultLogLevel 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.<br/>
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.WriteLogIf(System.Boolean,System.String,System.Object[])">
            <summary>
            주어진 조건을 만족하면 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="expr">조건식</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 기록되므로 
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의 <b>DefaultLogLevel</b>, <b>BaseLogLevel</b> 등의
            속성을 그대로 따른다. 따라서 <b>BaseLogLevel</b> 설정과 <b>DefaultLogLevel</b> 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.WriteLogIf(System.Boolean,TheOne.Diagnostics.LogLevel,System.String,System.Object[])">
            <summary>
            주어진 조건을 만족하면 주어진 로그 레벨로 로그 파일에 메시지를 기록한다.
            </summary>
            <param name="expr">조건식</param>
            <param name="level">로그 레벨</param>
            <param name="format">메시지 포맷</param>
            <param name="args">가변 매개변수</param>
            <remarks>
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 로그 메시지를 파일에 기록한다.
            로그 파일의 이름은 컴포넌트 이름(ComponentBase 클래스에서 파생된 구체 클래스의 이름)이 사용되며
            로그 파일이 생성되는 디렉터리는 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의 도움말을 참고하도록 한다.
            <br/><br/>
            로그 메시지는 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해 기록되므로
            <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스의  <b>DefaultLogLevel</b>, <b>BaseLogLevel</b> 등의
            속성을 그대로 따른다. 따라서  <b>BaseLogLevel</b> 설정과 <b>DefaultLogLevel</b> 설정에 따라서 로그 메시지가 필터링 될 수
            있음에 유의해야 한다.
            <br/><br/>
            이 메서드를 통해 기록되는 메시지는 메시지 앞에 컴포넌트 인스턴스 ID가 붙는다.
            이 인스턴스 ID는 System.Object.GetHashCode() 메서드가 반환하는 값을 사용하므로
            프로세스 내에서는 유일한 값이 된다. 하지만 프로세스가 재 시작되면 중복되는 ID가 발생할 수도 있다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.ExceptionHandler(System.Exception)">
            <summary>
            트랜잭션 컴포넌트의 사용자 정의 예외(exception) 처리 핸들러이다.
            </summary>
            <param name="ex">처리할 예외(exception) 객체</param>
            <returns>클라이언트 혹은 컴포넌트를 호출한 다른 컴포넌트에게 throw 할 예외 객체를 반환한다.</returns>
            <remarks>
            컴포넌트의 메서드 처리에서 발생하는 예외를 처리하는 공통 예외 처리 메서드이다.
            표준 구현은 <see cref="T:TheOne.Diagnostics.FileLogHelper">FileLogHelper</see> 클래스를 통해
            컴포넌트 로깅 파일에 <b>Error</b> 로그를 남긴다.
            <br/><br/>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스에서 파생된 클래스는 ExceptionHandler의 기본 구현을 사용하거나
            ExceptionHandler 메서드를 재정의(override) 하여 사용해야 한다. 권장되는 사용 방법은
            프로젝트 레벨의 기본 클래스에서 이 메서드를 재정의 하여 프로젝트 레벨의 표준 예외
            처리를 따르는 것이 좋다.
            <br/><br/>
            </remarks>
            
            <example>
            다음 코드는 ExceptionHandler의 기본 구현을 사용하는 예제 코드이다.
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                [AutoComplete]
                public void DoSomething()
                {
            		try {
            			// do your own task...
            		}
            		catch(Exception ex) {
            			ExceptoinHandler(ex);
            			throw;					// rethrow exception
            		}
                }
            }
            </code>
            다음 코드는 ExceptionHandler를 재정의하는 예제 코드이다.
            <code>
            public class Component1 : ComponentBase
            {
            	protected override Exception ExceptionHandler(Exception ex)
            	{
            		// 기술적 오류메시지를 감추고 사용자 친화적 메시지와 코드를 설정한다.
            		TheOneException newEx = new TheOneException("비즈니스 로직 오류 입니다.", base.ExceptionHandler(ex));
            		newEx.Code = -9010;
            		return newEx;
            	}
            	
                [AutoComplete]
                public void DoSomething()
                {
            		try {
            			// do your own task...
            		}
            		catch(Exception ex) {
            			ex = ExceptoinHandler(ex);
            			throw ex;
            		}
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.OnError(System.Exception)">
            <summary>
            컴포넌트 메서드 내에서 예외가 발생하면 수행 엔진이 호출을 하여 예외를 처리한다.
            </summary>
            <param name="ex">컴포넌트 메서드 내에서 발생한 예외 객체</param>
            <remarks>
            컴포넌트의 메서드를 수행하면서 예외가 발생하면 이 예외는 수행 엔진에 의해
            감지된다. 수행 엔진은 OnError 메서드를 호출하여 컴포넌트의 예외 처리를 중앙 집중적으로
            수행할 수 있도록 해준다. OnError 메서드가 호출되는 시점은 <see cref="M:TheOne.Transactions.ComponentBase.Deactivate">Deactivate()</see> 가 호출되고
            트랜잭션 문맥이 완료된 이후 이다. OnError 메서드에서 발생된 예외가 컴포넌트를 호출한
            호출자에게 전파되지 않도록 할 수 있는 방법은 없다. 예외가 전파되지 않도록 하기 위해서는
            컴포넌트의 메서드 내에서 try~catch를 사용해야만 한다.
            <para>이 메서드는 아무런 구현도 포함하고 있지 않다. 예외 처리를 원하는 컴포넌트는
            이 메서드를 재정의(override) 하여 예외 로깅 등의 작업을 수행할 수 있다.<br/>
            권장되는 방법은 어플리케이션 수준의 컴포넌트 기본 클래스에서 이 메서드를 재정의하여
            예외 로깅등의 작업을 수행하도록 하고, 각 구체 컴포넌트에서는 특별한 예외처리를 하지 않도록
            하는 것이다.</para>
            <para>컴포넌트 메서드가 예외를 try~catch 문에 의해 처리하고 예외를 다시 throw 하지 않으면
            수행 엔진이 예외를 감지할 수 없으며 OnError 메서드를 자동으로 호출해 주지도 않는다.</para>
            </remarks>
            <example>
            <code>
            public class Component1 : ComponentBase
            {
            	// 수행 엔진에 의해 예외 발생 시 호출된다.
            	protected override void OnError(Exception ex)
            	{
            		// ComponentBase.ExceptionHandler를 호출하여 예외 로그를 남긴다.
            		this.ExceptionHandler(ex);
            	}
            	
            	public void ErrorMethod()
            	{
            		throw new Exception("테스트를 위한 예외 발생");
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.SetComplete">
            <summary>
            메서드 종료 후 수행 문맥을 종료하고 트랜잭션을 <b>Commit</b>하도록 설정한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.SetAbort">
            <summary>
            메서드 종료 후 수행 문맥을 종료하고 트랜잭션을 <b>Abort</b>하도록 설정한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.ComponentBase.Dispose">
            <summary>
            Dispose 패턴을 구현한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.EventLog">
            <summary>
            이벤트 로그 기록을 위한 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의
            새 인스턴스를 초기화 한다.
            </summary>
            <remarks>
            EventLog 속성이 반환하는 <see cref="T:TheOne.Diagnostics.EventLogHelper">EventLogHelper</see> 클래스의
            인스턴스는 컴포넌트 이름을 이벤트 소스 이름으로 하는 이벤트 로그 메시지를 기록하도록 해준다.
            </remarks>
            <example>
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                [AutoComplete]
                public void DoSomething()
                {
                    // Simple File logging
                    base.WriteLog("DoSomething() invoked !!!");
                    // Event logging
                    base.EventLog.Write("DoSomething() invoked !!!");
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.PerfCounterEnabled">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운트 기능의 활성화 상태를 가져오거나 설정한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
            Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는
            성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
            소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
            <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
            측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
            카운터에 기록하도록 한다.
            </remarks>
            <example>
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                }
                
                [AutoComplete]
                public void DoSomething()
                {
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.PerfCounterMode">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운팅의 모드를 가져오거나 설정한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는 성능 카운팅은 Activate() 메서드의 호출부터
            Deactivate() 메서드의 호출 시점까지 이다. 즉, <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스가 제공하는
            성능 측정은 컴포넌트의 평균적인 활동 시간을 의미하며 구체적인 특정 메서드에
            소요되는 시간을 제공하지 않는다. 특정 메서드에 소요되는 시간을 측정하고자 하는 경우,
            <see cref="T:TheOne.Diagnostics.TimeCounter">TimeCounter</see> 클래스를 사용하여 시간을
            측정하고 그 결과를 파일에 기록하거나 <see cref="T:System.Diagnostics.PerformanceCounter">PerformanceCounter</see> 클래스를 통해 Windows 성능
            카운터에 기록하도록 한다.
            <br/><br/>
            성능 카운트 모드는 SimpleCounter와 SystemCounter 모드 두 종류를 지원한다.
            SimpleCounter는 단순히 파일에 Activate 부터 Deactivate 까지 소요된 시간을 기록한다.
            반면 SystemCounter는 Windows의 성능 카운터 기능을 이용하여 현재 활성화된 컴포넌트의
            개수, 초당 활성화된 컴포넌트의 개수, 활성화당 평균 소요시간 등의 상세한 정보를
            제공한다.
            <para>디폴트 값은 SimpleCounter 이다.</para>
            </remarks>
            <example>
            <code>
            public class Component1 : TheOne.Transactions.ComponentBase
            {
                public Component1()
                {
                    // Enable performace counting
                    base.PerfCounterEnabled = true;
                    // Seeting counter mode
                    base.PerfCounterMode = PerfCounterMode.SystemCounter;
                }
                
                [AutoComplete]
                public void DoSomething()
                {
                    // do your own task...
            		System.Threading.Thread.Sleep(1000);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.PerfLogTreshold">
            <summary>
            성능 카운터 로그를 기록여부를 결정하는 기준 카운터 값을 가져오거나 설정한다.
            </summary>
            <remarks>
            PerfCounterMode 속성이 Basic 혹은 Both 인 경우, 컴포넌트의 수행 시간을 나타나는
            성능 카운터 로그가 파일에 기록된다. 이 때, PerfLogThreshold 속성이 지정하는 값을
            초과하는 수행 시간에 대해서만 성능 카운터 로그가 기록되게 된다.<br/>
            예를 들어, 어떤 컴포넌트의 수행시간이 1200msec 일 때, PrefLogThreshold 속성 값이
            1500msec(기본값)이면 로그가 기록되지 않고, 1000msec 이라면 로그가 기록된다.<br/><br/>
            이 속성의 기본값은 1500msec 이며, configuration을 통해 설정할 수 있다.
            configuration 을 통한 설정은 전역 기본 값이며, 각 컴포넌트 별로 생성자에서
            이 속성의 값을 컴포넌트 별로 다른 값으로 설정할 수도 있다.<br/><br/>
            <b>주의) 이 속성은 Windows의 성능 카운터 기록과는 무관하다.</b>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.ForcePerfLog">
            <summary>
            성능 카운터 로깅을 PerfLogThreshold에 무관하게 수행할 수 있는 상태를 가져오거나 설정한다.
            </summary>
            <remarks>
            이 속성의 값이 <b>true</b> 이면 성능 카운터 로깅을 무조건 수행한다. 즉, PrefLogThrehold 설정을
            무시하고 컴포넌트가 수행한 시간을 로그 파일에 기록하게 된다.<br/>
            이 속성은 기본적으로 예외가 발생하여 ExceptionHandler 메서드가 호출되는 경우에
            자동으로 <b>true</b>로 설정된다.<br/>
            예외 발생과 무관하게 PrefLogThreshold 설정을 무시하고자 하는 경우, 컴포넌트의 생성자에
            이 속성의 값을 <b>true</b>로 설정하면 된다.<br/><br/>
            <b>주의 1) 이 속성은 Windows 성능 카운터 기록과는 무관하다.<br/>
            주의 2) PerfCounterEnabled 속성이 <b>false</b> 이면 이 속성의 값에 무관하게 기록은 남지 않는다.
            </b>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.UserID">
            <summary>
            컴포넌트를 호출한 사용자의 ID를 가져온다.
            </summary>
            <remarks>
            UserID 프로퍼티를 통해 사용자 ID가 설정되기 위해서 클라이언트는
            <see cref="T:TheOne.Security.UserInfoContext">UserInfoContext</see> 클래스의 인스턴스를
            생성하고 이 클래스의 <see cref="M:TheOne.Security.UserInfoContext.SetThreadPrincipal">SetCallContext</see>
            메서드를 해당 쓰레드에 대해 호출해 주어야 한다.
            <br/><br/>
            </remarks>
            <example>
            클라이언트 코드 예제
            <code>
            TheOne.Security.UserInfoContext ctx = new TheOne.Security.UserInfoContext("User1");
            ctx.SetCallContext();
            
            using(MyComp obj = new MyComp) {
               obj.DoIt();
            }
            </code>
            컴포넌트 코드 예제
            <code>
            public class MyComp : ComponentBase
            {
            	public void DoIt()
            	{
            		WriteLog("UserID = {0}", this.UserID);	// 출력은 User1 이 될 것이다.
            	}
            }
            </code>
            </example>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.UserInfo">
             <summary>
             컴포넌트를 호출한 사용자 정보를 담는 UserInfoContext 객체를 가져온다.
             </summary>
             <remarks>
             UserID 프로퍼티를 통해 사용자 ID가 설정되기 위해서 클라이언트는
             <see cref="T:TheOne.Security.UserInfoContext">UserInfoContext</see> 클래스의 인스턴스를
             생성하고 이 클래스의 <see cref="M:TheOne.Security.UserInfoContext.SetThreadPrincipal">SetCallContext</see>
             메서드를 해당 쓰레드에 대해 호출해 주어야 한다.
             <br/><br/>
             UserInfoContext 객체는 UserID 만을 담고 있기 때문에 추가적인 정보를 담기 위해서는
             UserInfoContext에서 상속받은 사용자 정의 사용자 정보 객체를 만들어야 한다. 다음 예제 코드는
             구체적인 방법을 보여주고 있다. 주의할 점은 상속 받은 MyUserInfoContext 객체는 반드시
             Serializable 특성(attribute)를 가져야 한다는 것이다.
             </remarks>
             <example>
             클라이언트 코드 예제
             <code>
             MyUserInfoContext ctx = new MyUserInfoContext("User1", "Dept #1");
             ctx.SetCallContext();
             
             using(MyComp obj = new MyComp) {
                obj.DoIt();
             }
             </code>
             컴포넌트 코드 예제
             <code>
             public class MyComp : ComponentBase
             {
            		// typed 액세스를 위해 UserInfo 프로퍼티를 재정의.
            		protected new MyUserInfoContext UserInfo
            		{
             		get { 
             			return (MyUserInfoContext)base.UserInfo;
             		}
            		}
            
            		public void DoIt()
            		{
            			WriteLog("UserID = {0}, Dept = {1}", this.UserID, this.UserInfo.DeptID);	// 출력은 User1, Dept #1 이 될 것이다.
            		}
             }
             
             [Serializable]
            	public class MyUserInfoContext : TheOne.Security.UserInfoContext
             {
             	private string _DeptID;
             
             	public MyUserInfoContext(string userID, string deptID) : base(userID) {
             		_DeptID = deptID;
             	}
             
             	public string DeptID {
             		get { return _DeptID; }
             	}
             }
             </code>
             </example>
        </member>
        <member name="P:TheOne.Transactions.ComponentBase.Context">
            <summary>
            컴포넌트의 메서드가 사용하는 수행 문맥을 가져온다.
            </summary>
            <value>컴포넌트의 메서드가 사용하는 수행 문맥을 나타내는 <see href="TheOne.Transactions.Common.ExecutinoContext">ExecutinoContext</see> 객체</value>
            <remarks>
            <para>
            <see cref="T:TheOne.Transactions.ComponentBase"/>에서 파생된 클래스의 메서드들이 호출될 때는 항상 수행 문맥을 갖는다.
            이 수행 문맥에는 메서드가 수행 될 때 필요한 트랜잭션 정보, 트랜잭션 <b>Commit/Rollback</b> 정보들을 담고 있다.
            수행 문맥이 포함하는 정보들에 대한 상세한 내용은 <see href="TheOne.Transactions.Common.ExecutinoContext">ExecutinoContext</see> 클래스를
            도움말을 참고하도록 한다.
            </para>
            <para>
            수행 문맥은 메서드가 호출될 때마다 프레임워크에 의해 설정되므로 하나의 수행 문맥은 하나의 메서드 호출 내에서만
            유효 하다. <br/>
            현재 구현 상 생성자의 호출 내에서는 수행 문맥은 존재하지 않으며 프레임워크가 제공하는 컴포넌트 서비스를
            사용할 수 없다. 따라서 Context 속성은 <b>null</b> 을 반환한다.
            </para>
            </remarks>
        </member>
        <member name="T:TheOne.Transactions.ILocalTransactionObject">
            <summary>
            로컬 트랜잭션 지원을 위한 인터페이스
            </summary>
        </member>
        <member name="M:TheOne.Transactions.ILocalTransactionObject.CreateDbInstance">
            <summary>
            DbAccess 개체를 생성합니다.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TheOne.Transactions.ILocalTransactionObject.EnlistTransaction(TheOne.Data.DbAccess)">
            <summary>
            로컬 트랜잭션에서 사용하는 DbAccess 개체를 사용하도록 설정합니다.
            </summary>
            <param name="db"></param>
        </member>
        <member name="F:TheOne.Transactions.DbObjectBase._DbAccess">
            <summary>
            DbObjectBase 클래스에서 사용하는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의
            인스턴스
            </summary>
            <remarks>
            DbAccess 클래스는 추상 클래스이므로 실제 인스턴스는 DbAccess에서 파생된
            SqlDbAccess 혹은 OleDbAccess 등의 인스턴스이다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.DbObjectBase.#ctor">
             <summary>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스의 새 인스턴스를 초기화 한다.  
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/>의 기본 생성자에서 <see cref="M:TheOne.Transactions.DbObjectBase.CreateDbInstance">CreateDbInstance</see> 메서드를
             호출하여 이 클래스가 사용할 DbAccess 객체를 내부적으로 유지한다. 또한 
             <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see> 속성의 기본값은 <b>false</b>로 설정한다
             <br/><br/>
             OpenOnActivate 속성의 기본 설정인 <b>false</b>를 바꾸기 위해서는 이 클래스에서 파생된 클래스는
             생성자에서 OpenOnActivate 속성 값을 변경하여야 한다.
             </remarks>
             <example>
             <code>
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return new SqlDbAccess();
             	}
            
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		// Close() method will be called automatically
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.DbObjectBase.Activate">
             <summary>
             컴포넌트가 활성화 되었음 알리는 메서드이다. <see cref="T:TheOne.Transactions.DbObjectBase"/>  클래스는 연관된
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see>의 데이터베이스 연결을 연다. 
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가 Activate 될 때
             연결 할 수 있으며 Deactivate 될 때 연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             <see cref="T:TheOne.Transactions.DbObjectBase"/>에서 파생된 클래스가 Activate를 재정의 하는 경우, 반드시
             기본 클래스의 <b>base.Activate()</b> 를 호출해 주어야 한다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	protected override void Activate() {
             		// you must call Activate() method of base class
             		base.Activate();
             		this.EventLog.Write("Activated...");
             	}
            
             	protected override void Deactivate() {
             		// you must call Deactivate() method of base class
             		this.EventLog.Write("Deactivated...");
             		base.Deactivate();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.DbObjectBase.Deactivate">
             <summary>
             컴포넌트가 비활성화 되었음 알리는 메서드이다. DbObjectBase 클래스는 연관된
             DbAccess의 데이터베이스 연결을 닫는다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가 <see cref="M:TheOne.Transactions.ComponentBase.Activate">Activate</see> 될 때
             연결 할 수 있으며 <see cref="M:TheOne.Transactions.ComponentBase.Deactivate">Deactivate</see> 될 때
             연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             DbObjectBase에서 파생된 클래스가 Deactivate를 재정의 하는 경우, 반드시
             기본 클래스의 <b>base.Deactivate()</b>를 호출해 주어야 한다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	protected override void Activate() {
             		// you must call Activate() method of base class
             		base.Activate();
             		this.EventLog.Write("Activated...");
             	}
            
             	protected override void Deactivate() {
             		// you must call Deactivate() method of base class
             		this.EventLog.Write("Deactivated...");
             		base.Deactivate();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess.Open() is already called
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.DbObjectBase.CreateDbInstance">
             <summary>
             데이터 컴포넌트(DbObjectBase 클래스에서 파생된 클래스)에서 사용할
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스에서 파생된 트랜잭션 컴포넌트에서 사용할 <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 객체를
             생성한다. 이 메서드를 재정의함으로써 <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 객체를 생성할 수 있고
              <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 객체에 연결문자열을 설정하는 등의 초기화 작업을 수행한다.
             이 메서드에서 생성한  <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 객체는 <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess">DbAccess</see> 속성을
             통해 액세스 할 수 있다.
             <br/><br/>
             CreateDbInstance 메서드는 <b>abstract</b> 메서드이므로 DbObjectBase 클래스에서 파생된
             모든 클래스는 이 메서드를 재정의 해야만 한다. DbObjectBase에서 파생된
             <see cref="T:TheOne.Transactions.DACBase">DACBase</see> 클래스는 이 메서드의 구현에서
             SqlDbAccess 클래스의 인스턴스를 생성하여 반환한다.
             SQL Server를 액세스하는 COM+ 컴포넌트는 DACBase에서 파생시키고
             다른 OLEDB 기반의 데이터베이스를 액세스하는 트랜잭션 컴포넌트가 필요하다면 OleDbObjectBase 를
             정의하고 이 클래스의 CreateDbInstance() 메서드에서 OleDbAccess 클래스의 인스턴스를 생성하여 반환하도록 한 후,
             컴포넌트들이 OleDbObjectBase 클래스에서 파생함으로써 CreateDbInstace() 메서드의 구현을 모든
             트랜잭션 컴포넌트가 수행해야 할 필요가 없도록 할 수 있다.
             </remarks>
             <returns>
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see>를 반환한다.
             </returns>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;		// override default
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// Setting hard-coded connection string.
             		// It is not recommanded to use hard-coded connection string.
             		// Using .config file and appSettings section, you can avoid hard-coded
             		// connection string.
             		// However, sometimes it is required to connect unusual data source,
             		// which is not a default data source.
             		// In such case, override CreateDbInstace() method for the unusal connection string.
             		return new SqlDbAccess("server=mydbserver;uid=sa;pwd=");
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess.Open() is already called.
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">
             <summary>
             컴포넌트가 Activate 와 Deactivate 될 때 데이터베이스 연결을 열고 닫을 수 있는 상태를 가져오거나 설정한다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스(혹은 파생 클래스)의 인스턴스를
             가진다. <see cref="P:TheOne.Transactions.DbObjectBase.DbAccess"/> 클래스의 데이터베이스 연결은 컴포넌트가Activate 될 때
             연결 할 수 있으며 Deactivate 될 때 연결을 닫을 수 있다. <br/>
             이러한 행동은 <see cref="P:TheOne.Transactions.DbObjectBase.OpenOnActivate">OpenOnActivate</see>
             속성의 값을 생성자에서 <b>true</b>로 지정함으로써 설정할 수 있다.
             <br/><br/>
             이 행동에 대한 설정은 OpenOnActivate 속성을 통해 실행한다. 이 속성이
             <b>true</b> 이면 Activate 또는 Deactivate에서 데이터베이스 연결을 열고 닫지만
             <b>false</b> 이면 이러한 데이터베이스 연결 작업을 <b>public</b> 메서드 내에서 수동으로 실행해야 한다.
             기본값은 <b>false</b> 이다.
             <br/><br/>
             OpenOnActivate 속성의 설정은 생성자에서만 효과를 나타낸다. 다른 메서드에서의 설정은
             효과를 나타내지 않는다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	public void DbComponent1() {
             		this.OpenOnActivate = true;	// overriding default beavior
             	}
             	
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return DatabaseFactory.CreateDatabase();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// Open() method was already called automatically.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
             		
             		// Close() method will be called automatically
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="P:TheOne.Transactions.DbObjectBase.DbAccess">
             <summary>
             데이터 컴포넌트에서 사용하는 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DbObjectBase"/> 클래스 (혹은 그 파생 클래스)는 데이터 컴포넌트가 사용하는
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스 혹은 그 파생 클래스의 인스턴스를
             가지고 있다. 이 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체는 <see cref="M:TheOne.Transactions.DbObjectBase.CreateDbInstance">CreateDbInstance</see> 메서드에서
             생성한 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체이며 이 객체를 통해 데이터베이스를 액세스 할 수 있다.
             </remarks>
             <example>
             <code>
             [Transaction(TransactionOption.Support)]
             public class DbComponent1 : DbObjectBase
             {
             	// must override this method
             	protected override DbAccess CreateDbInstance() {
             		// use default connection string from .config file
             		return new SqlDbAccess();
             	}
            
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
             		
             		// DbAccess property is the object which is created in CreateDbInstance() method.
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", ds);
             		return ds;
             	}
             }
             </code>
             </example>
        </member>
        <member name="M:TheOne.Transactions.DACBase.#ctor">
            <summary>	
            <see cref="T:TheOne.Transactions.DACBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
            <remarks>
            DACBase 클래스는 DbAccess 객체로서 SqlDbAccess 객체를 사용한다.
            즉, <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 속성는 SqlDbAccess 클래스의
            인스턴스이다. 따라서 이 클래스에서 파생된 클래스의 메서드들에서
            DbAccess 속성를 통해 데이터베이스를 액세스하는 경우 SQL Server를 사용하게
            되는 것이다.
            <br/><br/>
            OpenOnActivate 속성의 기본 설정인 <b>false</b>를 바꾸기 
            위해서는 이 클래스에서 파생된 클래스는 생성자에서 OpenOnActivate 속성 값을 바꾸어야 한다.
            </remarks>
            <example>
            <code>
            public class DbComponent1 : DACBase
            {
            	public void DbComponent1() {
            		this.OpenOnActivate = true;	// overriding default beavior
            	}
            	
            	[AutoComplete]
            	public DataSet GetData() {
            		DataSet ds = new DataSet();
            		
            		// Open() method was already called automatically.
            		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", "Test", ds);
            		this.DbAccess.ExecuteSql("SELECT * FROM tblTest2", "Test2", ds);
            		
            		// Close() method will be called automatically
            		return ds;
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.DACBase.CreateDbInstance">
             <summary>
              <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를 생성하여
             반환 함으로써 <see cref="T:TheOne.Transactions.DACBase"/>에서 파생된 클래스의 메서드들이 데이타베이스를 액세스
             할 수 있도록 한다.
             </summary>
             <remarks>
             <see cref="T:TheOne.Transactions.DACBase"/> 클래스의 CreateDbInstance() 구현은 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스를
             생성하여 반환하는 것이다. 생성된 <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 클래스의 인스턴스는 NeoDEEX 구성 파일의
             <b>databaseSection</b> 에서 <b>defaultDatabase</b> 의 속성값을 사용하여 초기화 된다.
             따라서 반드시 NeoDEEX 구성 파일의 <b>databaseSection</b>에 <b>defaultDatabase</b> 값에
             접속하고자 하는 기본 데이타베이스 연결문자열 컬렉션의 이름이 설정되어야 한다.
             <br/><br/>
             만약 특정 데이터 액세스 컴포넌트가 <b>defaultDatabase</b>의 값을 사용하지 않고
             제2, 제3의 데이터베이스에 접속한다면 CreateDbInstance() 메서드를 재정의하여
             다른 연결 문자열을 사용하도록 해야 한다.
             </remarks>
             <returns>
             <see cref="T:TheOne.Data.DbAccess">DbAccess</see> 객체를 반환한다.
             </returns>
             <example>
             SQL Server를 액세스하는 데이터 액세스 컴포넌트를 파생하여
             다음과 같이 작성한다.
             <code>
             public class DbComponent2 : DACBase
             {
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             어플리케이션의 대부분 데이터 액세스 컴포넌트가 이와 같이
             작동하지만 일부 예외적으로 다른 DB에 접근해야 하는 데이터 액세스 컴포넌트가 존재한다면
             CreateDbInstance 메서드를 재정의하여 별도의 연결문자열을 지정해 줄 수 있다.
             <code>
             public class DbComponent3 : DACBase
             {
                 protected override DbAccess CreateDbInstance()
                 {
             		return new SqlDbAccess("server=server2;uid=user2;pwd=pwd2");
                 }
                 
             	[AutoComplete]
             	public DataSet GetData() {
             		DataSet ds = new DataSet();
            
             		this.DbAccess.ExecuteSql("SELECT * FROM tblTest", ds);
            
             		return ds;
             	}
             }
             </code>
             위 코드에서 DbComponent2는 NeoDEEX 구성의 연결문자열을 사용하지만 DbComponent3는
             직접 연결 문자열을 지정함으로써 기본값으로 정이된 데이타베이스가 아닌 다른 데이타베이스에 접속한다.
             </example>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Save(System.Data.DataSet)">
            <summary>
            지정된 <see cref="T:System.Data.DataSet"/>에서 변경 사항(<b>Insert, Update, Delete</b>)을 커밋한다.
            </summary>
            <param name="ds">저장할 <see cref="T:System.Data.DataSet"/></param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Save(System.Data.DataTable)">
            <summary>
            지정된 <see cref="T:System.Data.DataTable"/>에서 변경 사항(<b>Insert, Update, Delete</b>)을 커밋한다.
            </summary>
            <param name="dt">저장할 <see cref="T:System.Data.DataTable"/></param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.SaveInternal(System.Data.DataTable)">
            <summary>
            <see cref="T:System.Data.DataRowState"/>를 기준으로 필터링된 내용이 모두 들어 있는  <see cref="T:System.Data.DataTable"/>의 복사본을 가져와서
            데이터테이블에 변경된 내용들을 커밋한다.
            레코드 변경 사항에 따라 <b>Insert, Update, Delete</b>가 호출된다.
            </summary>
            <remarks>
            저장 순서는 <b>Insert, Update, Delete</b> 이다. 즉, 모든 <b>Insert</b> 후에
            <b>Update, Delete</b>가 수행된다.
            </remarks>
            <param name="dt">커밋할 데이터 테이블</param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Insert(System.Data.DataRowCollection)">
            <summary>
            Insert를 수행할 Row들에 대해 InsertRow 메서드를 호출한다.
            </summary>
            <param name="rows">추가되어야 하는 <see cref="T:System.Data.DataRowCollection"/></param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Delete(System.Data.DataRowCollection)">
            <summary>
            Delete를 수행할 Row들에 대해 DeleteRow 메서드를 호출한다.
            </summary>
            <param name="rows">삭제가 될 <see cref="T:System.Data.DataRowCollection"/></param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Update(System.Data.DataRowCollection)">
            <summary>
            Update를 수행할 Row들에 대해 UpdateRow 메서드를 호출한다.
            </summary>
            <param name="rows">업데이트가 될 <see cref="T:System.Data.DataRowCollection"/></param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.Select(System.Object[])">
            <summary>
            지정된 인수를 사용하여 데이타를 검색한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.DACBase"/> 클래스의 Select 메서드는 아무런 작업도 수행하지 않고
            null을 반환한다. 이 메서드를 재정의하면 DataSet 객체
            (typed 혹은 untyped)를 생성하고 조회를 수행하고 그 결과를 DataSet
            객체에 Fill 한 후 DataSet을 반환한다.
            </remarks>
            <example>
            public override DataSet Select(params object[] param)
            {
            	DataSet ds = new DataSet();
            	// this.DbAccess 를 통한 데이터 액세스 및 DataSet 채우기(fill) 수행.
            	// 매개변수는 매개변수 배열을 통해 사용한다.
               return ds;
            }
            </example>
            <param name="param">Paramter 배열</param>
            <returns>DataSet을 반환한다.</returns>
        </member>
        <member name="M:TheOne.Transactions.DACBase.InsertRow(System.Data.DataRow)">
            <summary>
            <see cref="T:System.Data.DataRowCollection"/>에 추가된 Row에 대하여 Insert작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Added"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            데이터셋 내의 여러 테이블의 Insert된 행에 대해 InsertRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">삽입시킬 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.DeleteRow(System.Data.DataRow)">
            <summary>
            DataTable에서 삭제된 Row에 대하여 Delete 작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Deleted"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            <see cref="T:System.Data.DataSet"/> 안의 여러 테이블의 Delete된 행에 대해 DeleteRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">삭제가 되어질 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="M:TheOne.Transactions.DACBase.UpdateRow(System.Data.DataRow)">
            <summary>
            DataTable의 수정된 Row에 대하여 Update작업을 수행한다.
            이 메서드는 <b>Save()</b>에서 <see cref="T:System.Data.DataRow"/> 개체의 상태가 <see cref="F:System.Data.DataRowState.Modified"/>
            일 경우 호출되어 진다.
            </summary>
            <remarks>
            <see cref="T:System.Data.DataSet"/> 안의 여러 테이블의 Update된 행에 대해 UpdateRow가 수행되므로
            테이블에 대한 구분이 필요할 수도 있다. 이 때는 DataRow 객체의 <see cref="P:System.Data.DataRow.Table">Table</see>
            속성를 통해 구분할 수 있다.
            </remarks>
            <param name="row">업데이트가 되어질 <see cref="T:System.Data.DataRow"/> 객체</param>
        </member>
        <member name="T:TheOne.Transactions.Common.TransactionContextController">
            <summary>
            트랜잭션에 대한 처리를 수행하는 트랜잭션 컨트롤러.
            </summary>
            <remarks>
            트랜잭션 컨텍스트에 진입(Enter)하고 빠져나오거나(Leave), 트랜잭션을 시작해야 할지 등을 결정하는
            트랜잭션 컨트롤러이다. 이 클래스는 프레임워크 내부에서 사용되지만 사용자 정의 트랜잭션 제어를
            하고자 할 때는 이 클래스의 static 메서드들을 이용할 수 있다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.TransactionContextController.GetRootTransactionData(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            루트 트랜잭션의 트랜잭션 데이터를 반환한다.
            </summary>
            <param name="ctx">루트 트랜잭션을 찾기 위한 기준 수행 문맥</param>
            <returns>트랜잭션 데이터 객체</returns>
            <remarks>
            <para>
            컴포넌트 프레임워크는 트랜잭션의 전파 기능을 지원한다. 트랜잭션 전파란 어떤 컴포넌트의 트랜잭션이
            메서드 호출을 통해 다른 컴포넌트로 전파되는 것을 말한다. 예를 들어 어떤 컴포넌트 A의
            트랜잭션 옵션이 Required 이고 이 컴포넌트가 트랜잭션 옵션이 Supported 인 컴포넌트 B를 호출하면
            컴포넌트 A의 트랜잭션은 컴포넌트 B로 전파된다. 이 때 컴포넌트 B의 관점에서 트랜잭션이
            물리적으로 시작된 컴포넌트 A는 루트 트랜잭션 컴포넌트가 된다.
            </para>
            <para>
            <see href="TheOne.Transactions.Common.ITransactionControl">ITransactionControl</see> 인터페이스를
            사용자가 직접 구현하여 트랜잭션을 제어할 때 루트 트랜잭션의 정보를 사용해야 할 필요가 있다.
            이 메서드는 중첩된 수행 문맥을 검사하여 루트 트랜잭션을 포함하는 수행 문맥을 찾고 그 수행 문맥이 가지고 있는
            트랜잭션 데이터를 반환해 준다. 여기서 트랜잭션 데이터는 ITransactionControl 인터페이스의
            BeginTransaction 메서드 호출이 반환했던 트랜잭션 데이터 객체이다. 또한 프레임워크가
            루트 트랜잭션을 찾는 방법은 BeginTransaction 메서드가 out 매개변수로 반환한 isRoot 매개변수에
            의해 좌우 된다.
            </para>
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.TransactionContextController.Enter(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            트랜잭션 문맥에 진입한다. 항상 물리 트랜잭션이 시작하는 것은 아님에 유의한다.
            </summary>
            <param name="ctx">수행 문맥(ExecutionContext) 객체</param>
        </member>
        <member name="M:TheOne.Transactions.Common.TransactionContextController.Leave(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            트랜잭션 문맥에서 빠져나온다. 시작된 트랜잭션이 있다면 트랜잭션을 Commit/Abort하고 트랜잭션을 종료한다.
            </summary>
            <param name="ctx">수행 문맥(ExecutionContext) 객체</param>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionContextProperty">
            <summary>
            <para>이 클래스는 TheOne Framework 내부에서 사용하기 위한 클래스 이다.</para>
            <para>TranactionalContextProperty 클래스는 ComponentBase의 파생 클래스의 인스턴스에 대한
            메서드 호출을 가로채어(interception) 수행 처리(execution processing)를 담당하는
            ExecutionServerObjectSink을 추가하기 위해 사용된다.</para>
            </summary>
            <remarks>
            ContextProperty에 대한 상세한 사항은 닷넷 프레임워크의 ContextBoundObject 클래스와
            문맥에 관련된 도움말 및 자료를 살펴보도록 한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionContextProperty.System#Runtime#Remoting#Contexts#IContextProperty#Freeze(System.Runtime.Remoting.Contexts.Context)">
            <summary>
            IContextProperty 인터페이스의 Freeze 메서드 구현.
            </summary>
            <param name="newContext">새로이 생성된 컨텍스트 객체</param>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionContextProperty.System#Runtime#Remoting#Contexts#IContextProperty#IsNewContextOK(System.Runtime.Remoting.Contexts.Context)">
            <summary>
            <para>IContextProperty 인터페이스의 IsNewContextOK 메서드 구현.</para>
            <para>새로이 생성된 컨텍스트를 이상 유무를 확인한다.</para>
            </summary>
            <param name="newCtx">새로이 생성된 컨텍스트 객체</param>
            <returns>이상 유무</returns>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionContextProperty.System#Runtime#Remoting#Contexts#IContributeObjectSink#GetObjectSink(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMessageSink)">
            <summary>
            <para>IContributeObjectSink 인터페이스의 GetObjectSink 메서드 구현.</para>
            <para>TransactionalServerObjectSink 객체를 반환함으로써 트랜잭션 컴포넌트에 대한
            호출을 가로챌 수 있도록 설정한다.</para>
            </summary>
            <param name="obj">호출 대상 객체</param>
            <param name="nextSink">다음 메시지 싱크 객체</param>
            <returns>메시지 체인에 추가할 ServerObjectSink 객체</returns>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContextProperty.System#Runtime#Remoting#Contexts#IContextProperty#Name">
            <summary>
            <para>IContextProperty 인터페이스의 Name 속성 구현.</para>
            <para>컨텍스트 속성의 이름을 반환한다(읽기 전용).</para>
            </summary>
        </member>
        <member name="T:TheOne.Transactions.BIZBase">
            <summary>
            트랜잭션 처리 컴포넌트를 사용하는 비즈니스 로직 컴포넌트의 기본 클래스를 정의한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.BIZBase"/> 클래스는 비즈니스 로직 컴포넌트에 대한 기본 클래스로서 사용된다.<br/>
            비록 <see cref="T:TheOne.Transactions.DbObjectBase">DbObjectBase</see> 클래스처럼 데이터베이스 연결을 관리하는 등의
            특별한 기능을 가지고 있지 않지만 단일 추상 클래스에서 파생하여 일관된 클래스 계층 구조를 갖도록 할 수 있다. 
            <see cref="T:TheOne.Transactions.BIZBase"/> 클래스가 독자적인 기능을 갖고 있지 않지만
            <see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스에서 파생되었으므로
            <see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스가 갖는 파일 로깅, 이벤트 로깅, 성능 측정 기능 등은 여전히 사용할 수 있다.	<br/>
            <see cref="T:TheOne.Transactions.BIZBase"/> 클래스에 선언된 <b>TheOne.Transactions</b> 관련 특성(attribute)은 이 클래스의 기본 클래스인
            <see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스의 특성(attribute)을
            상속 받는다. 다만, Transaction 특성(attribute)은 <b>Required</b> 로 기본 설정되어 있다. 대개의 비즈니스 로직 컴포넌트가
            <b>Required</b> 트랜잭션 설정을 갖기 때문이다. 이 클래스에서 파생된 클래스가 명시적으로 Transaction 특성(attribute)을 주지 않는다면
            트랜잭션 속성은 <b>Required</b>가 된다. 또한 Transaction Isolation Level의 기본값은 <b>ReadCommitted</b>를
            사용한다.
            <para>주의할 사항으로 이 클래스에는 <see cref="T:TheOne.Transactions.AutoCompleteAttribute">AutoCompleteAttribute</see>가 표시되어 있지
            않다는 점이다. COM+와의 하위 호환성을 위한 것으로써 이 클래스에서 직접 파생된 클래스는 메서드 수준 혹은 클래스 수준에서
            <b>AutoComplete</b>를 명시하지 않으면 메서드 내에서 <see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스의
            <see cref="M:TheOne.Transactions.ComponentBase.SetComplete">SetComplete</see> 와 <see cref="M:TheOne.Transactions.ComponentBase.SetAbort">SetAbort</see> 
            메서드를 호출하거나 <see cref="T:TheOne.Transactions.ContextUtil"/> 클래스의 <see cref="M:TheOne.Transactions.ContextUtil.SetComplete">SetComplete</see> 와 <see cref="M:TheOne.Transactions.ContextUtil.SetAbort">SetAbort</see>
            메서드를 직접를 호출해 주어야 한다.</para>
            <para>하위 호환성이 문제가 되지 않는 경우라면(COM+ 코드를 TheOne.Transactions로 마이그레이션 하는 경우가 아니라면),
            <see cref="T:TheOne.Transactions.BIZBase"/>에서 파생된 클래스를 정의하고 이 클래스에 <see cref="T:TheOne.Transactions.AutoCompleteAttribute">AutoCompleteAttribute</see>를 
            명시하고 이 클래스로부터 파생하여 비즈니스 로직 컴포넌트를 작성하는 것이 좋다.</para>
            </remarks>
            <example>
            	<code lang="CS" description="다음 예제 코드는 BIZBase 클래스에서 직접 파생된 BizComponent1 클래스를 정의하고 &#xA;            데이터 액세스 컴포넌트인 DbComponent1 클래스를 호출한다. DoBizLogic 메서드는 트랜잭션 하에서 수행된다. AutoCompleteAttribute 특성이 DoBizLogic 메서드에 표시되어 있음에 주목해야 한다. AutoComplete 특성이 명시되어 있으면 트랜잭션은 메서드 종료시 자동으로 커밋되며, 예외가 발생하면 트랜잭션은 취소된다.">
            // NOTE :: default transaction option is 'Required'
            public class BizComponent1 : BIZBase
            {
                [AutoComplete]
                public int DoBizLogic()
                {
                    // Write your biz logic code...
                    // In this simple example, just invoke data access component which is derived from
                    // DbObjectBase class.
                    using(DbComponent1 obj = new DbComponent1()) {
                        DataSet ds = obj.GetData();
                        return ds.Tables[0].Rows.Count;
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.BIZBase.#ctor">
            <summary>
            <see cref="T:TheOne.Transactions.BIZBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControllerInfo.GetTransactionController">
            <summary>
            트랜잭션을 제어할 트랜잭션 컨트롤러 인터페이스 입니다.
            (<see href="TheOne.Transactions.Common.ITransactionControl">ITransactionControl</see>)를 반환합니다.
            </summary>
            <returns>트랜잭션을 제어하는 <see href="TheOne.Transactions.Common.ITransactionControl">ITransactionControl</see> 인터페이스 입니다.</returns>
        </member>
        <member name="M:TheOne.Transactions.TransactionControllerAttribute.TheOne#Transactions#Common#ITransactionControllerInfo#GetTransactionController">
            <summary>
            <see cref="T:TheOne.Transactions.Common.ITransactionControl"/> 클래스의 새 인스턴스를 초기화하고 반환한다.
            </summary>
            <returns><see cref="T:TheOne.Transactions.Common.ITransactionControl"/> 객체</returns>
        </member>
        <member name="T:TheOne.Transactions.Common.ITransactionControl">
            <summary>
            트랜잭션을 제어하는 트랜잭션 인터페이스를 나타낸다.
            </summary>
            <remarks>
            	<para>
            		ITransactionControl 인터페이스는 컴포넌트 프레임워크의 트랜잭션 컨텍스트 컨트롤러에 의해 사용되는 인터페이스이다.
            		트랜잭션 문맥 컨트롤러는 ITransactionControl 인터페이스의
            		<see cref="M:TheOne.Transactions.Common.ITransactionControl.BeginTransaction(TheOne.Transactions.Common.ExecutionContext,System.Boolean@)">BeginTransaction</see> 메서드를 호출하여 트랜잭션을 시작하며
            		또 필요에 따라 <see cref="M:TheOne.Transactions.Common.ITransactionControl.EndTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">EndTransaction</see> 메서드를 호출하여 트랜잭션을 종료한다. 
            		또한 트랜잭션의 Commit/Abort를 결정하기 위해 이 인터페이스의 <see cref="M:TheOne.Transactions.Common.ITransactionControl.CommitTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">CommitTransaction</see> 메서드와
            		<see cref="M:TheOne.Transactions.Common.ITransactionControl.AbortTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">AbortTransaction</see> 메서드를 호출한다.
            	</para>
            	<para>
                    ITransactionControl 인터페이스는 <see href="TheOne.Transactions.TransactionAttribute">TransactionAttribute</see>와 같은
                    트랜잭션 특성(attribute)가 구현하는 <see href="TheOne.Transactions.Common.ITransactionInfo">ITransactionInfo</see>의
                    <see href="TheOne.Transactions.Common.ITransactionInfo.GetTransactionControl">GetTransactionControl</see> 메서드를
                    통해 트랜잭션 프레임워크에게 제공된다. 프레임워크는 트랜잭션 특성이 제공하는 ITransactionControl 인터페이스를
                    통해 트랜잭션을 시작하고 <b>Commit</b>/<b>Abort</b> 하며 트랜잭션을 종료한다.
                </para>
            	<para>ITransactionControl 인터페이스를 구현하는 클래스는 BeginTransaction 메서드 내에서
                System.Transactions 나 COM+, SWC(Service Without Component), ADO.NET Local Transaction 과 같은
                트랜잭션 인프라를 사용하여 트랜잭션을 시작할 수 있다. <a href="TheOne.Transactions.TransactionAttribute">TransactionAttribute</a> 특성은
                System.Transactions 를 이용하여 트랜잭션을 관리하며 ITransactionControl의 메서드들 호출에 대해 반응한다.</para>
            	<para>사용자는 이 인터페이스를 구현하는 어트리뷰트를 구현함으로써 사용자 정의 트랜잭션 제어를 수행 할 수 있다. 상세한 내용은 TheOne
                Technology 의 기술지원을 요청하도록 한다.</para>
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.Initialize(TheOne.Transactions.TransactionInfo)">
            <summary>
            트랜잭션 컨트롤러를 초기화 한다.
            </summary>
            <param name="txInfo">트랜잭션 정보를 나타내는 <see href="TransactionInfo">TransactionInfo</see> 객체</param>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.BeginTransaction(TheOne.Transactions.Common.ExecutionContext,System.Boolean@)">
            <summary>
            트랜잭션을 시작한다.
            </summary>
            <param name="ctx">트랜잭션을 시작하는 수행 문맥(<see href="ExecutionContext">ExecutionContext</see>) 객체</param>
            <param name="isRoot">루트 트랜잭션 여부</param>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.EndTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">
            <summary>
            트랜잭션을 종료한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.CommitTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">
            <summary>
            트랜잭션이 Commit으로 종료 되도록 설정한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.AbortTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">
            <summary>
            트랜잭션이 Abort로 끝나도록 설정한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionControl.IsInTransaction(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            수행 문맥이 트랜잭션 내에서 존재하는가를 반환한다.
            </summary>
            <param name="ctx">수행 문맥을 나타내는 <see href="ExecutionContext">ExecutionContext</see> 객체</param>
            <returns>수행 문맥이 트랜잭션 내에서 수행 중이라면 true를, 그렇지 않거나 ctx 매개변수가 null 이면 false를 반환한다.</returns>
        </member>
        <member name="T:TheOne.Transactions.ApplicationNameAttribute">
            <summary>
            트랜잭션 응용프로그램 이름을 지정한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.ApplicationNameAttribute.#ctor(System.String)">
            <summary>
            트랜잭션 응용프로그램 이름을 지정하여 <see cref="T:TheOne.Transactions.ApplicationNameAttribute"/> 클래스의 새 인스턴스를 초기화 한다.
            </summary>
            <param name="name">트랜잭션 응용프로그램 이름</param>
        </member>
        <member name="P:TheOne.Transactions.ApplicationNameAttribute.ApplicationName">
            <summary>
            트랜잭션을 처리하는 응용프로그램의 이름을 가져온다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.TransactionOption">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스에 의해 수행되는 메서드들의 트랜잭션 형식을 지정한다.
            </summary>
            <remarks>
            	TransactionOption 열거자는 System.EnterpriseServices 네임스페이스의 TransactionOption
                열거자나 System.Transactions 네임스페이스의 TransactionOption 열거자와 다르다.
                System.EnterpriseServices 네임스페이스의 TransactionOption 열거자는 COM+가 명시하는 <b>Disabled,
                NotSupported, Supported, Required, RequiesNew</b> 다섯가지의 옵션을 명시할 수 있으나
                System.Transactions 네임스페이스의 TransactionOption 열거자는 <b>Suppress, Required, RequiresNew</b>
                세가지만을 사용할 수 있다. Suppress는 기존의 NotSupported와 동일하며 Required, RequiresNew는 COM+의 그것과
                같다.
            	<para>TheOne.Transactions 네임스페이스의 TransactionOption은 이전 TransactionOption 들을 통합하여
                명시하는 것으로써 다음과 같은 호환성을 갖는다.</para>
            	<para>
            		<table class="" style="BORDER-RIGHT: 1px solid; BORDER-TOP: 1px solid; BORDER-LEFT: 1px solid; BORDER-BOTTOM: 1px solid" cellspacing="0" cols="4" cellpadding="0">
            			<tbody>
            				<tr>
            					<td><strong>System.EnterpriseServices</strong></td>
            					<td><strong>System.Transactions</strong></td>
            					<td><strong>TheOne.Transactions</strong></td>
            				</tr>
            				<tr>
            					<td>Disabled</td>
            					<td>N/A (Transaction 사용 안함)</td>
            					<td>None</td>
            				</tr>
            				<tr>
            					<td>NotSupported</td>
            					<td>Supress</td>
            					<td>Supress</td>
            				</tr>
            				<tr>
            					<td>Supported</td>
            					<td>N/A (Transaction 사용 안함)</td>
            					<td>Supported</td>
            				</tr>
            				<tr>
            					<td>Required</td>
            					<td>Required</td>
            					<td>Required</td>
            				</tr>
            				<tr>
            					<td>RequiesNew</td>
            					<td>RequiresNew</td>
            					<td>RequiresNew</td>
            				</tr>
            			</tbody>
            		</table>
            	</para>
            </remarks>
            <notes><para>TransactionOption은 컴포넌트가 어떤 트랜잭션 제어를 사용하는가에 따라 의미가 달라진다.</para></notes>
        </member>
        <member name="F:TheOne.Transactions.TransactionOption.None">
            <summary>
            트랜잭션 옵션이 주어지지 않는 상황으로 기존 트랜잭션이 있는 경우, 이 트랜잭션에 포함되어 코드가 수행되고 그렇지 않다면 트랜잭션과 무관하게
            코드가 수행된다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionOption.Supported">
            <summary>
            None 과 같은 동작을 수행한다. ServicedComponent에서 파생된 클래스의 Migration을 위해서
            제공하는 특성이다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionOption.Suppress">
            <summary>코드는 항상 현재 트랜잭션과 무관하게 수행된다.</summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionOption.Required">
            <summary>
            트랜잭션이 이미 시작되었다면 코드는 이 트랜잭션에 포함되어 수행되고, 그렇지 않다면
            새로운 트랜잭션을 시작하고 코드가 수행된다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionOption.RequiresNew">
            <summary>
            항상 새로운 트랜잭션을 생성하고 코드는 새로이 생성된 트랜잭션 하에서 수행된다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.PerfCounterInstaller">
            <summary>
            트랜잭션 컴포넌트 성능 카운터 설치 클래스이다.
            </summary>
            <remarks>
            트랜잭션 컴포넌트 성능 카운터를 설치한다. 이 클래스는 installutil.exe 프로그램에 의해
            성능카운터가 설치될 때 사용되는 클래스로서 개발자는 사용하지 않는 클래스이다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.PerfCounterInstaller.#ctor">
            <summary>
            <see cref="T:TheOne.Transactions.PerfCounterInstaller"/> 클래스의 새 인스턴스를 초기화 한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.PerfCounterInstaller.SetupPerformanceCounterInstaller">
            <summary>
            성능 카운터 설치 관련 코드
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Controllers">
            <summary>
            Transaction Controller에 대한 열거형입니다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.Controllers.FastTransaction">
            <summary>
            CommittableTransaction를 사용하는 FastTransactionController 입니다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.Controllers.TransactionScope">
            <summary>
            TransactionScope를 사용하는 TransactionScopeController 입니다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.Controllers.LocalTransaction">
            <summary>
            로컬 트랜잭션을 사용하는 LocalTransactionController 입니다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionContextAttribute">
            <summary>
            <para>이 클래스는 TheOne Framework 내부에서 사용하기 위한 클래스 이다.</para>
            <para><see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스에서 파생된 
            트랜잭션 컴포넌트의 컨텍스트 관리를 위한 Context 특성(attribute) 클래스.</para>
            </summary>
            <remarks>
            이 특성은 ComponentBase 클래스에 표시된 특성으로서 ContextBoundObject의 파생 클래스에만
            유효하다. 이 특성은 ComponentBase의 파생 클래스의 인스턴스가 독자적인 닷넷 컨텍스트를
            갖도록 강제하며, 이를 통해 ServerObjectSink 가 메서드 호출을 가로채어(intercept) 트랜잭션
            문맥하에서 컴포넌트가 작동되도록 해준다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionContextAttribute.System#Runtime#Remoting#Contexts#IContextAttribute#GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage)">
            <summary>
            <para>IContextAttribute 인터페이스의 GetPropertiesForNewContext 메서드 구현.</para>
            </summary>
            <param name="msg">IConstructionCallMessage 인터페이스를 구현하는 메시지 객체</param>
            <remarks>
            이 메서드는 항상 메서드 호출을 가로채기 위해 ServerObjectSink를 달고 있는
            TransactionalContextProperty 속성을 메시지에 추가한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionContextAttribute.System#Runtime#Remoting#Contexts#IContextAttribute#IsContextOK(System.Runtime.Remoting.Contexts.Context,System.Runtime.Remoting.Activation.IConstructionCallMessage)">
            <summary>
            <para>IContextAttribute 인터페이스의 IsContextOK 메서드 구현.</para>
            <para>모든 <see>ComponentBase</see> 클래스(혹은 파생 클래스)의 인스턴스에 대한 호출을
            가로채기 위해 호환되는 컨텍스트는 존재하지 않는 것으로 설정한다. 즉, 이 메서드는 항상
            false를 반환한다.
            </para>
            </summary>
            <param name="ctx">컨텍스트 객체</param>
            <param name="msg">IConstructionCallMessage 인터페이스를 구현하는 메시지 객체</param>
            <returns>컨텍스트 호환 여부</returns>
        </member>
        <member name="T:TheOne.Transactions.Resources.Default">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ComponentBase_ComponentBase_1">
            <summary>
              Looks up a localized string similar to 유효하지 않은 전역 로깅 카운터 기준값({0})이 사용되어 디폴트 값({1})을 사용합니다..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ComponentBase_SetExecutionContext_1">
            <summary>
              Looks up a localized string similar to The execution context is already set or it is different to ExecutionContext.Current..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ContextUtil_EnsureAutoCompleteDisabled_1">
            <summary>
              Looks up a localized string similar to This operaion is not supported with automatic complete(AutoComplete == true).
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ContextUtil_EnsureExecutionContext_1">
            <summary>
              Looks up a localized string similar to There is no current execution context. (ExecutionContext.Current == null).
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.DbObjectBase_EnlistTransaction_1">
            <summary>
              Looks up a localized string similar to DbAccess 속성이 NULL이 아니므로 트랜잭션에 참여할 수 없습니다..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.DBParamCollection_OnActivate_1">
            <summary>
              Looks up a localized string similar to Activated :: COM+ 성능 카운터를 기록하는 도중 오류가 발생되었습니다. 성능 카운터를 Disable 합니다. 상세한 오류메시지는 다음과 같습니다.\r\n\r\n{0}.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ExecutionServerObjectSink_ExecutionServerObjectSink_1">
            <summary>
              Looks up a localized string similar to Type should be inheried from ComponentBase class..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ExecutionServerObjectSink_IMessageSink_AsyncProcessMessage_1">
            <summary>
              Looks up a localized string similar to Asynchronous Trnasactional Method Call is not supported..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ExecutionServerObjectSink_ProcessMessage_1">
            <summary>
              Looks up a localized string similar to Cannot build ExecutionInfo. Refer inner exception information..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ExecutionServerObjectSink_ProcessMessage_2">
            <summary>
              Looks up a localized string similar to Cannot enter to execution context. Refer inner exception information..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.ExecutionServerObjectSink_ProcessMessage_3">
            <summary>
              Looks up a localized string similar to General Error in processing execution context. Refer inner exception information..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.LocalTransactionController_BeginTranssaction_1">
            <summary>
              Looks up a localized string similar to 대상 컴포넌트가 ILocalTransactionObject 인터페이스를 구현하지 않아서 LocalTransactionController를 사용할 수 없습니다..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.PerfCounterMgr_EnsureCounterExists_1">
            <summary>
              Looks up a localized string similar to TheOne.Transactions 성능 카운터가 존재하지 않아 새로이 생성합니다..
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.PerfCounterMgr_Init_1">
            <summary>
              Looks up a localized string similar to 성능 카운터를 초기화 할 수 없습니다. 카운터가 존재하지 않거나 생성에 실패했습니다. 오류로 인해 성능 카운터가 Disable 됩니다. 상세한 오류 정보는 다음과 같습니다.\r\n\r\n{0}.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.PerfCounterMgr_OnDeactivate_1">
            <summary>
              Looks up a localized string similar to Deactivated :: COM+ 성능 카운터를 기록하는 도중 오류가 발생되었습니다. 성능 카운터를 Disable 합니다. 상세한 오류메시지는 다음과 같습니다.\r\n\r\n{0}.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Resources.Default.TransactionContextController_Enter_1">
            <summary>
              Looks up a localized string similar to Transaction controller should not be null..
            </summary>
        </member>
        <member name="T:TheOne.Transactions.PerfCounterMgr">
            <summary>
            트랜쟉션 컴포넌트의 성능 카운터(Performance Counter)를 처리하는 클래스이다.<br/> 
            이 클래스는 NeoDEEX 내부에서만 사용하는 클래스이다.
            </summary>
            <remarks>
            트랜잭션 컴포넌트의 성능 카운터는 다음과 같은 정보를 제공한다.<br/>
            <li>
            	<ul>현재 활성화되어 수행되고 있는 컴포넌트의 개수</ul>
            	<ul>초당 수행되는 컴포넌트의 개수</ul>
            	<ul>컴포넌트가 수행되는 평균 수행 시간</ul>
            </li>
            트랜잭션 컴포넌트 성능 카운터는 프로세스에 관계없이 전체 시스템에 대한 카운터 값과
            각 시스템마다 카운터 값을 제공한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.PerfCounterMgr.Init(System.Boolean)">
            <summary>
            성능 카운터를 초기화하며 필요한 경우 새로운 성능카운터 인스턴스를 만들어 초기화한다.
            </summary>
            <param name="install">설치에 의해 초기화 되었는가 여부</param>
            <returns>성능카운터의 초기화 성공 여부를 반환한다.</returns>
        </member>
        <member name="M:TheOne.Transactions.PerfCounterMgr.ResetAllCounterValue">
            <summary>
            트랜잭션 컴포넌트의 성능 카운터들을 모두 초기화 한다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.DebugUtils">
            <summary>
            TheOne.Transactions 내부에서 사용되는 유틸리티 메서드이다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.GetNormalizedMethodName(System.Diagnostics.StackFrame)">
            <summary>
            주어진 스택 프레임으로 부터 클래스 이름을 포함하는 메서드 이름을 읽어
            반환한다.
            </summary>
            <param name="frame">스택 프레임</param>
            <returns>메서드 이름</returns>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.GetCallerMethodName(System.Int32)">
            <summary>
            호출자 메서드의 이름(클래스 이름 포함)을 반환한다.
            </summary>
            <returns>호출자 메서드의 이름을 반환한다.</returns>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.DumpCallStack">
            <summary>
            현재 메서드의 호출 스택을 표시한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.ShowContextID">
            <summary>
            ContextID 값을 출력한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.WriteLog(System.Int32,System.String,System.Object[])">
            <summary>
            로그 메시지를 출력한다.
            </summary>
            <param name="depth">호출 스택의 깊이</param>
            <param name="format">메시지 포맷</param>
            <param name="args">매개변수</param>
            <remarks>
            이 메서드를 직접 호출하는 경우, depth의 값은 1로 설정한다.
            만약, 간접적으로 호출하는 경우, 호출 경로에 따라 depth를 결정하면 된다.
            WriteLog 메서드 자체가 호출 스택을 차지하므로 depth의 값은 1보다 크게 주어야만 한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.WriteLog(System.Int32,System.Int32,System.String,System.Object[])">
            <summary>
            로그 메시지를 출력한다.
            </summary>
            <param name="depth">호출 스택의 깊이</param>
            <param name="spaceCount">메서드 이름 앞에 들어갈 공백 개수</param>
            <param name="format">메시지 포맷</param>
            <param name="args">매개변수</param>
            <remarks>
            이 메서드를 직접 호출하는 경우, depth의 값은 1로 설정한다.
            만약, 간접적으로 호출하는 경우, 호출 경로에 따라 depth를 결정하면 된다.
            WriteLog 메서드 자체가 호출 스택을 차지하므로 depth의 값은 1보다 크게 주어야만 한다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.DebugUtils.WriteLog(System.String,System.Object[])">
            <summary>
            로그 메시지를 출력한다.
            </summary>
            <param name="format">메시지 포맷</param>
            <param name="args">매개변수</param>
        </member>
        <member name="T:TheOne.Transactions.TransactionIsolationLevel">
            <summary>
            트랜잭션 격리 수준을 지정한다.
            </summary>
            <remarks>
            IsolationLevel 열거자는 트랜잭션의 격리 수준을 지정하는데 사용된다. 이 열거자는
            System.EnterpriseServices의 Isolation 열거자와 다르다. 이 열거자는
            TransactionIsoalationLevel 열거자 보다는 System.Transactions 네임스페이스의
            IsolationLevel 열거자와 호환되도록 되어 있다. 따라서 SWC (Services Without Components)를
            사용하는 경우, 일부 트랜잭션 격리 수준은 예외를 발생할 수도 있다.
            </remarks>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.Unspecified">
            <summary>
            지정된 격리 수준과 다른 수준이 사용되지만 수준을 결정할 수는 없다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.Chaos">
            <summary>
            격리 수준이 높은 트랜잭션에서 보류 중인 변경은 덮어쓸 수 없다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.ReadUncommitted">
            <summary>
            공유 잠금이 발행되지 않았고 단독 잠금이 부여되지 않았음을 의미하는 더티 읽기가 가능하다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.ReadCommitted">
            <summary>
            공유 잠금은 커밋되지 않은 읽기를 방지하기 위해 데이터를 읽는 동안
            유지되지만 트랜잭션이 끝나기 전에 데이터가 변경되어 반복되지 않은 읽기나 팬텀 데이터가 생성될 수 있다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.RepeatableRead">
            <summary>
            잠금은 쿼리에서 사용되는 모든 데이터에 적용되어 데이터를 다른 사용자가 업데이트할 수 없게 한다. 
            반복되지 않은 읽기를 금지하지만 팬텀 행의 경우는 가능합니다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.Serializable">
            <summary>
            범위 잠금을 DataSet에 적용하여 트랜잭션이 완료될 때까지 
            다른 사용자가 데이터 집합에 행을 삽입하거나 업데이트할 수 없게 한다.
            </summary>
        </member>
        <member name="F:TheOne.Transactions.TransactionIsolationLevel.Snapshot">
            <summary>
            동일한 데이터에 대해 한 응용 프로그램에서 데이터를 수정하고 있을 때 또 다른 응용 프로그램에서 읽을 수 있는 데이터 버전을 저장하여 차단을 줄일 수 있다. 
            다시 쿼리해도 한 트랜잭션에서 다른 트랜잭션의 변경 내용을 볼 수 없음을 나타낸다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionInfo">
            <summary>
            <para>ExecutionInfo 클래스는 <see herf="ComponentBase">ComponentBase</see>에서 파생된 클래스의
            메서드들에 대한 수행 정보를 담는 클래스로써 수행 확장(Execution Extension)과 트랜잭션 정보 등의
            정보를 담고 있다.</para>
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionInfo.GetExecutionInfo(System.Reflection.MethodBase)">
            <summary>
            <para>주어진 메서드에 대한 <see href="ExecutionInfo">ExecutionInfo</see> 객체를 구한다.</para>
            </summary>
            <param name="method">메서드에 대한 reflection 객체</param>
            <returns>ExecutionInfo 객체</returns>
            <remarks>
            <para>메서드에 대한 ExecutionInfo 객체는 항상 반환되며 null 인 경우는 없다.
            내부적으로 ExecutionInfo 객체에 대한 캐시 테이블이 존재하며 이 캐시에 ExecutionInfo 객체가 이미
            존재하는 경우 이것을 사용하고 존재하지 않는 경우 새로운 객체를 생성하여 캐시를 업데이트 하고
            이를 반환한다.</para>
            <para>메서드에 수행 확장이나 트랜잭션 설정, <b>AutoComplete</b> 설정 중 어느 하나라도 존재하는 경우,
            메서드에 대한 고유의 ExecutionInfo 객체가 존재하고 이를 사용한다. 하지만 이들 모두가 존재하지
            않는 경우 클래스의 수행 확장, 트랜잭션, <b>AutoComplete</b> 설정이 메서드에 적용되며 클래스의
            ExecutionInfo 객체를 사용한다. 클래스 내에 고유의 ExecutionInfo를 보유하지 않은 메서드들은
            모두 이 클래스 수준의 ExecutionInfo를 공유 한다.</para>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.ApplicationName">
            <summary>
            어플리케이션 이름을 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.ClassName">
            <summary>
            클래스 이름을 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.ClassType">
            <summary>
            클래스 타입 객체를 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.TrackingEnabled">
            <summary>
            메서드 호출 추적의 활성화 여부를 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.TransactionInterface">
            <summary>
            트랜잭션 제어 인터페이스를 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.TransactionInfo">
            <summary>
            트랜잭션 정보 객체를 반환한다.
            </summary>
            <value>트랜잭션 정보를 나타내는 TransactionInfo 구조체</value>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.IsAutoComplete">
            <summary>
            AutoComplete 설정 여부를 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.Extensions">
            <summary>
            수행 확장(execution extension)을 위한 확장 객체들의 리스트를 반환한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionInfo.MethodAnnotated">
            <summary>
            메서드에 트랜잭션, <b>AutoComplete</b>, 수행 확장에 관련된 특성들이 존재하는지 여부를 반환한다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.TransactionInfo">
            <summary>
            트랜잭션에 관련된 정보를 나타내는 클래스이다.
            </summary>
            <remarks>
            트랜잭션에 관련된 정보를 알아내는 가장 대표적인 방법은 <see cref="T:TheOne.Transactions.ContextUtil">ContextUtil</see> 클래스의
            <see href="TheOne.Transactions.ContextUtil.TransactionInfo">TransctionInfo</see>
            속성의 값을 가져오는 것이다. 이 속성은 현재 컨텍스트가 사용하는 트랜잭션 정보를 반환한다. 이외에도 TransactionInfo 클래스는 다양한
            상황에서 트랜잭션에 대한 정보를 나타낸다. 이 클래스는 상속 될 수 없다.
            </remarks>
            <example>
                다음 코드는 ContextUtil의 TransactionInfo 속성을 통해 현재 컨텍스트를 사용하는 트랜잭션 정보를 읽는 방법을 보여주고 있다.
                <code lang="CS">
            [Transaction(TransactionOption.RequiresNew, 
            IsolationLevel = TransactionIsolationLevel.ReadCommitted, Timeout = 120)]
            public class MyComponent : TheOne.Transactions.ComponentBase
            {
                // Verify class level transation setting
                [AutoComplete]
                public void TransactionInfoTest1()
                {
                   TransactionInfo txInfo = ContextUtil.TransactionInfo;
                   Debug.Assert(txInfo.TransactionOption == TransactionOption.RequiresNew);
                   Debug.Assert(txInfo.IsolationLevel == TransactionIsolationLevel.ReadCommitted);
                   Debug.Assert(txInfo.Timeout == 120);
                }
             
                // Verify method level transation setting
                [Transaction]
                [AutoComplete]
                public void TransactionInfoTest2()
                {
                   TransactionInfo txInfo = ContextUtil.TransactionInfo;
                   Debug.Assert(txInfo.TransactionOption == TransactionOption.Required);
                   Debug.Assert(txInfo.IsolationLevel == TransactionIsolationLevel.ReadCommitted);
                   Debug.Assert(txInfo.Timeout == 60);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.TransactionInfo.#ctor(TheOne.Transactions.TransactionOption,TheOne.Transactions.TransactionIsolationLevel,System.Int32)">
            <summary>
            지정된 트랜잭션 형식, 트랜잭션 격리수준 형식, 트랜잭션 타임아웃 시간을 이용하여
            <see cref="T:TheOne.Transactions.TransactionInfo"/> 클래스의 새 인스턴스를 정적으로 초기화 한다. 
            </summary>
            <param name="option">트랜잭션 형식</param>
            <param name="isolationLevel">트랜잭션 격리수준 형식</param>
            <param name="timeout">트랜 잭션 타임 아웃 시간(초)</param> 
        </member>
        <member name="P:TheOne.Transactions.TransactionInfo.TransactionOption">
            <summary>
            트랜잭션 형식을 가져온다.
            </summary>
            <value>트랜잭션 형식을 나타내는 <see href="TransactionOption">TransactionOption</see> 형식의 값</value>
            <remarks>
            트랜잭션 형식, 격리 수준은 어떤 트랜잭션 인프라를 사용하는가에 따라 그 의미가 달라지거나
            지원되지 않는 것들이 존재할 수 있다. 예를 들어 <see href="TransactionAttribute">TransactionAttribute</see>
            는 System.Transactions 을 사용한다. 따라서 <see href="TransactionOption"/> 형식의 <b>NotSupported</b> 값은
            단순히 <see cref="T:System.Transactions.TransactionScope">TransactionScope</see>를 사용하지 않는 것을 의미한다. 
            만약 어떤 트랜잭션 특성이 System.Transactions 대신
            COM+ SWC(Service Without Component)를 사용한다면 <see href="TransactionOption"/> 형식의 <b>NotSupported</b>값은
            의미를 갖게 된다.
            <para>
            트랜잭션 수행 옵션에 대한 상세한 내용은 <see href="TransactionOption">TransactionOption</see> 열거자와
            <see href="TransactionAttribute">TransactionAttribute</see>과 같은 각 트랜잭션 특성을 참고하도록 한다.
            </para>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.TransactionInfo.IsolationLevel">
            <summary>
            트랜잭션 격리 수준(isolation level)을 가져온다. 
            </summary>
            <value>트랜잭션 격리 수준을 나타내는 <see href="TransactionIsolationLevel">TransactionIsolationLevel</see> 형식의 값</value>
            <remarks>
            트랜잭션 형식, 격리 수준은 어떤 트랜잭션 인프라를 사용하는가에 따라 그 의미가 달라지거나
            지원되지 않는 것들이 존재할 수 있다. 예를 들어 <see href="TransactionAttribute">TransactionAttribute</see>
            는 System.Transactions 을 사용한다. 따라서 <see href="TransactionOption"/> 형식의 <b>NotSupported</b> 값은
            단순히 <see cref="T:System.Transactions.TransactionScope">TransactionScope</see>를 사용하지 않는 것을 의미한다. 
            만약 어떤 트랜잭션 특성이 System.Transactions 대신
            COM+ SWC(Service Without Component)를 사용한다면 <see href="TransactionOption"/> 형식의 <b>NotSupported</b>값은
            의미를 갖게 된다.
            <para>
            트랜잭션 격리 수준에 대한 상세한 내용은 <see href="TransactionIsolationLevel">TransactionIsolationLevel</see> 열거자와
            <see href="TransactionAttribute">TransactionAttribute</see>과 같은 각 트랜잭션 특성을 참고하도록 한다.
            </para>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.TransactionInfo.Timeout">
            <summary>
            트랜잭션 타임아웃 값(초 단위)을 가져온다.
            </summary>
            <value>타임 아웃 시간을 초 단위로 나타내는 정수값</value>
        </member>
        <member name="T:TheOne.Transactions.TransactionAttribute">
            <summary>
            <see cref="T:TheOne.Transactions.ComponentBase"/> 에서 파생된 클래스 혹은 이 클래스의 메서드, 속성에 적용되는
            트랜잭션 속성을 나타낸다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.ITransactionInfo">
            <summary>트랜잭션 제어에 필요한 트랜잭션 정보, 트랜잭션 컨트롤러 인터페이스 등의 정보를 제공하는 인터페이스를 나타낸다.</summary>
            <remarks>
            	<para>ITransactionInfo 인터페이스는 트랜잭션을 제어하는 특성(attribute)에 의해 구현되는 인터페이스이다. 이 인터페이스를
                구현하는 대표적인 특성은 <see href="TheOne.Transactions.TransactionAttribute">TransactionAttribute</see>로써 컴포넌트가 사용할
                트랜잭션의 정보를 제공한다. 이 인터페이스의 <see href="TheOne.Transactions.Common.ITransactionInfo.GetTransactionInfo">GetTransactionInfo</see>
                메서드는 컴포넌트에 표시된 트랜잭션 제어 옵션, 격리 수준, 타임아웃 정보 등을 제공하고 
                <see href="TheOne.Transactions.Common.ITransactionInfo.GetTransactionController">GetTransactionController</see> 메서드는
                컴포넌트의 트랜잭션을 처리할 때 사용할 트랜잭션 컨트롤러에 대한 
                <see href="TheOne.Transactions.Common.ITransactionControl">ITransactionControl</see> 인터페이스를 반환한다.
                </para>
            	<para>
            	컴포넌트 프레임워크의 수행 문맥(<see href="ExecutionContext">ExecutionContext</see>) 컨트롤러는 GetTransactionInfo 메서드를 호출하여 컴포넌트에 설정된 트랜잭션 정보를 읽고 이 정보를
            	바탕으로 어떤 컴포넌트가 트랜잭션 처리가 필요한가를 판단한다. 만약 컴포넌트가 트랜잭션 처리가 필요하다면
            	(대개 <see href="TheOne.Transactions.TransactionOption">TransactionOption</see> 열거자가 <b>None</b>이 아닌 경우이다.)
            	GetTransactionController를 호출하여 트랜잭션 컨트롤러에 대한 ITransactionControl 인터페이스를 구하고
            	이 인터페이스의 <see cref="M:TheOne.Transactions.Common.ITransactionControl.BeginTransaction(TheOne.Transactions.Common.ExecutionContext,System.Boolean@)">BeginTransaction</see> 메서드를 호출하여 트랜잭션을 시작하며
            	또 필요에 따라 <see cref="M:TheOne.Transactions.Common.ITransactionControl.EndTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">EndTransaction</see> 메서드를 호출하여 트랜잭션을 종료한다. 
            	또한 트랜잭션의 <b>Commit</b>/<b>Abort</b>를 결정하기 위해 이 인터페이스의 <see cref="M:TheOne.Transactions.Common.ITransactionControl.CommitTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">CommitTransaction</see> 메서드와
            	<see cref="M:TheOne.Transactions.Common.ITransactionControl.AbortTransaction(TheOne.Transactions.Common.ExecutionContext,System.Object)">AbortTransaction</see> 메서드를 호출한다.
                </para>
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.ITransactionInfo.GetTransactionInfo">
            <summary>
            트랜잭션 정보(<see href="TheOne.Transactions.TransactionInfo">TransactionInfo</see>)를 반환한다.
            </summary>
            <returns>트랜잭션 정보를 나타내는 <see href="TheOne.Transactions.TransactionInfo">TransactionInfo</see> 객체</returns>
            <remarks>
            ITransactionInfo 인터페이스를 구현하는 트랜잭션 특성(attribute)는 트랜잭션에서 사용할
            트랜잭션의 제어 옵션, 격리 수준, 타임 아웃 정보를 <see href="TheOne.Transactions.TransactionInfo">TransactionInfo</see>
            객체를 통해 트랜잭션 문맥 관리자에게 반환해야 한다. 이 메서드에서 반환한 트랜잭션 정보는
            실제로 트랜잭션을 시작하는데 필요한 정보로써 사용된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.TransactionAttribute.#ctor">
            <summary>
            <see cref="P:TheOne.Transactions.TransactionAttribute.TransactionOption"/> 형식의 <b>Required</b> 를 지정하여 클래스 혹은 메서드의 트랜잭션 속성을 설정을 하여
             <see cref="T:TheOne.Transactions.TransactionAttribute"/> 클래스의 새 인스턴스를 초기화 한다. 
            </summary>
            <remarks>
            기본 트랜잭션 격리 수준은 <b>ReadCommitted</b> 이며 기본 트랜잭션 타임아웃은 60초이다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.TransactionAttribute.#ctor(TheOne.Transactions.TransactionOption)">
            <summary>
            지정된 <see cref="P:TheOne.Transactions.TransactionAttribute.TransactionOption"/>을 지정하여 <see cref="T:TheOne.Transactions.TransactionAttribute"/> 클래스의 새 인스턴스를 초기화 한다. 
            </summary>
            <param name="option">트랜잭션 형식,<see cref="P:TheOne.Transactions.TransactionAttribute.TransactionOption"/>값 </param>
            <remarks>
            기본 트랜잭션 격리 수준은 <b>ReadCommitted</b> 이며 기본 트랜잭션 타임아웃은 60초이다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.TransactionAttribute.TheOne#Transactions#Common#ITransactionInfo#GetTransactionInfo">
            <summary>
            트랜잭션 정보 객체를 반환한다.
            <see cref="T:TheOne.Transactions.TransactionInfo"/> 클래스의 새 인스턴스를 초기화하고 반환한다.
            </summary>
            <returns><see cref="T:TheOne.Transactions.TransactionInfo"/> 객체</returns>
        </member>
        <member name="P:TheOne.Transactions.TransactionAttribute.TransactionOption">
            <summary>
            <see cref="P:TheOne.Transactions.TransactionAttribute.TransactionOption"/> 형식을 가져오거나 설정한다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.TransactionAttribute.IsolationLevel">
            <summary>
            트랜잭션의 트랜잭션 격리 수준(transaction isolation level)을 가져오거나 설정한다.
            기본값은 <b>ReadCommitted</b> 이다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.TransactionAttribute.Timeout">
            <summary>
            트랜잭션의 타임아웃을 가져오거나 설정한다. 단위는 초이며 기본값은 60초(COM+ 기본값과 동일) 이다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.IExecutionExtension">
            <summary>
            트랜잭션 컴포넌트의 수행 확장(Execution extension)을 지원하는 특성(attribute)들이
            구현해야할 인터페이스를 나타낸다.
            </summary>
            <remarks>
            	수행 확장(Execution Extension)은 메서드가 호출되기 전과 호출 된 후에 추가적인 작업을 수행할 수 있는 컴포넌트의 기능 확장을
                말한다. 수행 확장은 IExecutionExtension 인터페이스를 구현하는 특성(attribute)으로써 정의되고 수행 확장 특성을 클래스 혹은
                메서드에 표시하여 사용할 수 있다.
            	<para>컴포넌트 프레임워크 인프라는 컴포넌트의 메서드가 호출되기 전에 <see cref="M:TheOne.Transactions.Common.IExecutionExtension.PreProcess(TheOne.Transactions.Common.ExecutionContext)">
                PreProcess</see> 메서드를 호출하여 수행 확장이 메서드 수행 전의 전처리(pre-processing)을 수행할 수 있도록 해주며, 컴포넌트
                메서드가 호출된 후에 <see cref="M:TheOne.Transactions.Common.IExecutionExtension.PostProcess(TheOne.Transactions.Common.ExecutionContext)">
                PostProcess</see> 메서드를 호출하여 수행 확장이 후처리(post-processing)을 수행할 수 있도록 해준다. 수행 확장을 통해
                어플리케이션은 Spring.NET 과 같이 AOP(Aspect Oriented Programming) 방식의 프로그래밍 모델을 사용할 수 있는
                것이다.</para>
            	<para>수행 확장을 적용할 수 있는 전형적인 예제는 로깅(logging)이나 예외 처리이다. 예를 들어 컴포넌트 메서드에서 발생하는 예외를 중앙
                집중적으로 처리하고자 한다면, <see cref="T:TheOne.Transactions.Common.IExecutionExtension"/>을 구현하는 ExceptionHandleExtension 특성을 구현하고
                <see cref="M:TheOne.Transactions.Common.IExecutionExtension.PostProcess(TheOne.Transactions.Common.ExecutionContext)">PostProcess</see> 메서드에서 <see cref="T:TheOne.Transactions.Common.ExecutionContext">ExecutionContext</see>의 
                <see cref="P:TheOne.Transactions.Common.ExecutionContext.Exception">Exception</see>속성을 통해 컴포넌트 메서드에서 발생한 예외에 대한 
                로깅 처리를 수행할 수 있다.
                </para>
                <para>수행 확장 특성은 클래스 혹은 메서드에 명시될 수 있다. 메서드에 명시된 수행 확장은 해당 메서드가 호출될 때만 전처리/후처리가 가능하며
                클래스에 명시된 수행 확장은 그 클래스의 <b>public</b>, <b>internal</b> 메서드에 적용된다. 만약 수행 특성이 메서드와 클래스 내에 모두 명시되면
                메서드의 수행 확장이 먼저 호출된 후에 클래스의 수행확장이 호출된다(같은 수행 확장이 클래스와 메서드에 모두 명시되더라도 모두 호출됨에 유의). 수행
                확장은 특성으로 구현되기 때문에 클래스 상속에 의해 수행 확장 역시 상속될 수 있다. 클래스 상속에 의해 수행 확장이 상속되면 상속된 수행 확장은
                가장 나중에 호출된다. 동일 수준(메서드 혹은 클래스)에서 2개 이상의 수행 확장이 사용되면 이들 수행 확장의 호출 순서는 일정하지
                않다.</para>
            	<para>앞서 언급한대로 하나의 메서드에 적용되는 수행 확장은 1개 이상일 수 있기 때문에 <see cref="M:TheOne.Transactions.Common.IExecutionExtension.PreProcess(TheOne.Transactions.Common.ExecutionContext)">PreProcess</see> 메서드가 호출되는 순서는 메서드 수준
                수행확장, 클래스 수준의 수행 확장, 상속된 수행 확장 순서대로 호출되며 같은 수준에서 사용되는 수행 확장의 호출 순서를 일정하지 않다.
                PostProcess 메서드가 호출되는 순서는 <see cref="M:TheOne.Transactions.Common.IExecutionExtension.PostProcess(TheOne.Transactions.Common.ExecutionContext)">PostProcess</see> 메서드가 호출되는 순서의 역순이다.</para>
            </remarks>
            <example>
                다음 예제는 ExceptionHandlerExtension 수행 확장을 구현하고 컴포넌트의 클래스 수준에서 적용하는 예제를 보여주고 있다.
                ExceptionHandlerExtension 특성이 상속되지 않도록(Inherit = false) 설정되어 있으므로 파생 클래스의 메서드에서
                명시적으로 ExceptionHandlerExtension 특성을 사용하고 있다.
                <code title="[New Example]">
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
            public class ExceptionHandlerExtensionAttribute : Attribute, IExecutionExtension
            {
                public int Initialize(Type type, System.Reflection.MethodBase method)
                {
                    // do nothing. must return 0;
                    return 0;
                }
             
                public void PreProcess(ExecutionContext ctx)
                {
                    // do noting.
                }
             
                public void PostProcess(ExecutionContext ctx)
                {
                    // if there is an exception, log it.
                    if (ctx.Exception != null) {
                        WriteExceptionLog(ctx.Exception);
                    }
                }
             
                private static void WriteExceptionLog(Exception ex)
                {
                    // write exception logging to file.
                    FileLogHelper.Write("Errors", LogLevel.Error, "EXCEPTION ========\r\n{0}", ex.ToString());
                }
             
            }
             
            [Transaction]
            [AutoComplete]
            [ExceptionHandlerExtension]
            public class BizComponent : ComponentBase
            {
                public void DoBusinessLogic()
                {
                    throw new Exception("Test exception #1. It will be logged.");
                }
            }
             
            // Transaction and AutoComplete setting is inherited,
            // but ExecptionHanderExtension is not inherited because Inherited property 
            // of the attribute is false.
            public class DerivedBizComponent : BizComponent
            {
                public void OtherLogic()
                {
                    throw new Exception("Test exception #2. It will not be logged.");
                }
             
                [ExceptionHandlerExtension]
                public void AnotherLogic()
                {
                    throw new Exception("Test exception #3. It will be logged."); 
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.Common.IExecutionExtension.Initialize(System.Type,System.Reflection.MethodBase)">
            <summary>수행 확장(Execution Extension)을 초기화 한다.</summary>
            <returns>예약 되어 있다. 현재에는 항상 0을 반환해야 한다.</returns>
            <remarks>
            	<para>수행 확장은 클래스 혹은 메서드 수준에서 특성(attribute)을 통해 명시된다. 컴포넌트 프레임워크는 특정 메서드가 최초로 호출될 때
                해당 메서드에 어떤 수행 확장이 존재하는지 그리고 그 메서드를 포함하는 클래스의 수행 확장이 존재하는지 확인하여 수행 확장 목록을 구성한다. 이 수행
                확장 목록이 구축될 때 IExecutionExtension 인터페이스의 Initialize 메서드가 호출된다.</para>
            	<para>Initialize 메서드는 특성이 표시될 때에 1회만 호출된다. 예를 들어 IExecutionExtension 인터페이스를 구현하는 구현
                확장이 A, B 2개의 클래스에 표시되고 다른 C 클래스 내의 2개의 메서드에 명시된다면 Initialize 메서드는 모두 4회
                호출된다.</para>
            	<para>전역 수행 확장은 Initialize 메서드는 1회만 호출되어 진다.</para>
            </remarks>
            <param name="type">수행 확장 객체가 적용되는 타입.</param>
            <param name="method">수행 확장 객체가 적용되는 메서드. 클래스 수준에서 수행 확장이 명시된 경우에는 null 이 전달 된다.</param>
        </member>
        <member name="M:TheOne.Transactions.Common.IExecutionExtension.PreProcess(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            컴포넌트 메서드 호출 전에 필요한 전처리 작업을 수행한다.
            </summary>
            <param name="ctx">수행 문맥(<see href="ExecutionContext">ExecutionContext</see>) 객체</param>
            <remarks>
            컴포넌트 프레임워크에 의해 호출되어지며 수행 문맥(<see href="ExecutionContext">ExecutionContext</see>)이 
            시작한 직후에 호출된다. 트랜잭션 문맥은
            아직 시작하기 전이며 컴포넌트의 Activate 메서드도 호출되기 전 상태에 호출된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.Common.IExecutionExtension.PostProcess(TheOne.Transactions.Common.ExecutionContext)">
            <summary>
            컴포넌트 메서드 호출 후에 필요한 후처리 작업을 수행한다.
            </summary>
            <param name="ctx">수행 문맥(<see href="ExecutionContext">ExecutionContext</see>) 객체</param>
            <remarks>
            컴포넌트 프레임워크에 의해 호출되어지며 수행 문맥(<see href="ExecutionContext">ExecutionContext</see>)이 
            종료되기 직전에에 호출된다. 컴포넌트의 Deactivate 메서드가 이미 호출된 후이며
            트랜잭션 문맥은 이미 종료되어 <b>Commit</b>/<b>Abort</b> 단계까지 수행된 상태에서 호출되어 진다.
            </remarks>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionExtensions">
            <summary>
            IExecutionExtension 인터페이스를 구현하는 Attribute 들에 대한 컬렉션.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionContextController">
            <summary>
            컨텍스트를 제어하는 컨트롤러 클래스.
            컨텍스트에 진입하거나 빠져 나오며 현재 수행 문맥(current execution context)을
            관리한다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.AutoCompleteAttribute">
            <summary>
            특성을 사용하는 메서드나 클래스를 <b>AutoComplete</b> 개체로 표시하여 트랜잭션 투표에 대한 제어를 자동으로 실행한다.
            </summary>
            <remarks>
            <see cref="T:TheOne.Transactions.ComponentBase">ComponentBase</see> 클래스에서 파생된 클래스의 메서드들은
            수동으로 트랜잭션을 제어하도록 되어 있다.<br/>
            트랜잭션을 자동으로 제어하기 위해서는 <b>AutoComplete</b>를 클래스 혹은 메서드 수준에 
            명시해야 한다. <b>AutoComplete</b>를 명시하는 경우, 메서드가 정상적으로 종료하면 
            트랜잭션을 완료하고 예외를 throw하는 경우에는 트랜잭션이 중단된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.AutoCompleteAttribute.#ctor">
            <summary>
            트랜잭션을 자동으로 제어 하도록 설정하여 <see cref="T:TheOne.Transactions.AutoCompleteAttribute"/> 클래스의 새 인스턴스를 초기화 한다.
            </summary>
        </member>
        <member name="M:TheOne.Transactions.AutoCompleteAttribute.#ctor(System.Boolean)">
            <summary>
            <b>AutoComplete</b> 활성화 여부를 지정하여 <see cref="T:TheOne.Transactions.ComponentBase"/> 클래스의 새 인스턴스를 초기화 한다.  
            </summary>
            <param name="isAutoComplete"><b>AutoComplete</b>를 활성화하면 <b>true</b>이고, 그렇지 않으면 <b>false</b>이다.</param>
        </member>
        <member name="P:TheOne.Transactions.AutoCompleteAttribute.IsAutoComplete">
            <summary>
            트랜잭션 자동 제어 활성화 여부 상태를 가져온다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionContext">
            <summary>
            컴포넌트 메서드의 컨텍스트 정보를 가져온다. 이 클래스는 상속되지 않는다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.Id">
            <summary>
            ExecutionContext의 ID를 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.MethodCallMessage">
            <summary>
            이 컨텍스트를 사용하는 메서드에 대한 호출 메시지를 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.MethodReturnMessage">
            <summary>
            이 컨텍스트를 사용하는 메서드의 호출 결과 메시지를 가져온다. 만약 메서드가 아직 완료되지 않았다면 <b>null</b> 을 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.Exception">
            <summary>
            이 컨텍스트를 사용하는 메서드의 호출 도중 발생한 예외 객체를 가져온다. 만약 예외를 발생하지 않았다면 <b>null</b> 을 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.MethodName">
            <summary>
            실행 할 메서드 또는 실행 중인 메서드 이름을 가져온다 .
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.MethodBase">
            <summary>
            수행하고자 하는 혹은 수행 중인 메서드에 대한 
            리플렉션 정보(<see href="System.Reflection.MethodBase">MethodBase</see> 객체)를 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.TargetObject">
            <summary>
            수행 대상인 객체를 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.Data">
            <summary>
            <see href="IExecutionExtension">IExecutionExtesion</see> 인터페이스를 통해 수행 확장을
            실행하는 경우 사용할 수 있는 사용자 정의 데이터 객체를 가져온다.
            </summary>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.TransactionInfo">
            <summary>
            컨텍스트의 트랜잭션 정보를 가져온다.
            </summary>
            <value>컨텍스트의 트랜잭션 정보를 나타내는 <see cref="P:TheOne.Transactions.Common.ExecutionContext.TransactionInfo"/> 객체를 가져온다. 만일 트랜잭션을 사용하지 않는 경우 <b>null</b>을 반환한다.</value>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionContext.Current">
            <summary>
            현재 컨텍스트를 나타내는 <see cref="T:TheOne.Transactions.Common.ExecutionContext"/> 객체를 가져온다.
            </summary>
        </member>
        <member name="T:TheOne.Transactions.ContextUtil">
            <summary>
            트랜잭션 컴포넌트들의 컨텍스트에 대한 정보를 가져온다.
            </summary>
            <remarks>
            System.EnterpriseServices 네임스페이스에 <see href="System.EnterpriseServices.ContextUtil">ContextUtil</see>
            클래스가 존재하듯이 TheOne.Transactions 네임스페이스도 ContextUtil 클래스를 제공한다. 이 클래스에는
            현재 컨텍스트의 정보를 제공하거나 트랜잭션의 종료 및 트랜잭션 <b>Commit</b>/<b>Abort</b>를 제어할 수 있는 속성과 메서드들을
            제공한다. 두 클래스의 속성과 메서드는 상당히 유사한 점들이 많기 때문에 System.EnterpriseServices 기반의
            기존 코드를 TheOne.Transactions 기반으로 마이그레이션할 때에도 이 클래스는 매우 유용하다.
            <para>
            COM+는 기본 문맥(context)이란 것이 존재하기 때문에
            System.EnterpriseServices.ContextUtil 클래스의
            메서드 및 속성을 임의의 시점에서 액세스 하더라도 문제가 없지만, TheOne.Transactions 은
            컴포넌트의 메서드가 호출될 때에만 유효한 수행 문맥(<see href="TheOne.Transactions.ExecutionContext">ExecutionContext</see>)을
            갖기 때문에 이다. 
            유효한 수행 문맥이 존재하지 않을 때 <see cref="T:System.InvalidOperationException">InvalidOperaionExecption</see>을 유발한다.
            또, <see cref="T:TheOne.Transactions.AutoCompleteAttribute">AutoCompleteAttribute</see> 특성이 <b>true</b>로 설정된 상황에서 트랜잭션의 결과는
            메서드 내에서 예외(exception)이 발생했는가에 의해 <b>Commit</b>/<b>Abort</b>가 결정되므로 
            수동으로 트랜잭션의 결과를 제어하는 <see href="SetComplete">SetComplete</see> 와 <see href="SetComplete">SetAbort</see>
            메서드의 호출은 아무런 의미도 없다. 따라서 코드의 명확성과 일관성을 위해 이 두 메서드가 <b>AutoComplete</b>가 <b>true</b>로
            설정된 상황에서 호출되면 <see cref="T:System.InvalidOperationException">InvalidOperaionExecption</see>을 유발한다.
            </para>
            </remarks>
            <example>
                다음 예제 코드는 <see cref="T:TheOne.Transactions.TransactionAttribute">Transaction</see>
                특성을 이용하여 컴포넌트의 메서드들이 트랜잭션 내에서 수행되도록 하고 있다.<see cref="T:TheOne.Transactions.AutoCompleteAttribute">AutoComplete</see>
                특성이 명시되지 않은 메서드는 트랜잭션의
                <b>Commit</b>/<b>Abort</b>를 제어하기 위해 <b>SetComplete</b> 와 <b>SetAbort</b> 메서드를 호출하고 있음에 주목해야 한다. 또한 <see cref="T:TheOne.Transactions.ContextUtil"/> 클래스의
                <see cref="P:TheOne.Transactions.ContextUtil.IsInTransaction">IsInTransction</see>
                속성을 통해 메서드가 트랜잭션 내에서 수행 중인가를 확인하고 있다.<br/>
            	<code lang="CS">
            [Transaction]
            public class MyComponent : TheOne.Transactions.ComponentBase
            {
                public void ManualTransactionControl()
                {
                    try {
                        // transaction has started.
                        // confirm the transaction.
                        Debug.Assert(ContextUtil.IsInTransaction == true);
                    
                        // Do some business logic or data access in the transaction
                        
                        // AutoComplete is not set.
                        // Transaction result is determined manully
                        ContextUtil.SetComplete();
                    }
                    catch (Exception) {
                        // The transction shold be aborted.
                        ContextUtil.SetAbort();
                        // re throw the exception for notifying to caller
                        throw;
                    }
                }
                
                [AutoComplete]
                public void AutoTransactionControl()
                {
                    // transaction has started.
                    // confirm the transaction.
                    Debug.Assert(ContextUtil.IsInTransaction == true);
             
                    // Do some business logic or data access in the transaction
                    
                    // The transaction will be committed automatically if there is no exception.
                    // Otherwise, the transaction will be aborted.
                }
            }
            </code>
            </example>
        </member>
        <member name="M:TheOne.Transactions.ContextUtil.EnableCommit">
            <summary>
            현재 컨텍스트의 <b>ShouldCommit</b> 비트를 <b>true</b> 로 설정한다.
            따라서 수행 문맥이 종료될 때 트랜잭션이 <b>Commit</b>된다. 
            </summary>
            <exception cref="T:System.InvalidOperationException">
            컨텍스트의 <b>AutoComplete</b> 설정이 <b>true</b> 인 상황에서 <b>SetComplete</b> 
            혹은 SetAbort 호출이 수행되면 발생한다.
            이는 일관성을 위한 것으로써 <b>AutoComplete</b>가 설정된 상황에서 <b>SetComplete</b> 와 <b>SetAbort</b>를 호출하는 실수를
            막기 위한 것이다.
            </exception>
            <remarks>
            현재 구현 상 메서드가 종료하면 수행 문맥은 항상 종료 된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ContextUtil.DisableCommit">
            <summary>
            현재 컨텍스트의 <b>ShouldCommit</b> 비트를 <b>false</b> 로 설정한다.
            따라서 수행 문맥이 종료될 때 트랜잭션이 <b>Abort</b>된다. 
            </summary>
            <exception cref="T:System.InvalidOperationException">
            컨텍스트의 <b>AutoComplete</b> 설정이 <b>true</b> 인 상황에서 <b>SetComplete</b> 혹은 <b>SetAbort</b> 호출이 수행되면 발생한다.
            이는 일관성을 위한 것으로써 <b>AutoComplete</b>가 설정된 상황에서 <b>SetComplete</b> 와 <b>SetAbort</b>를 호출하는 실수를
            막기 위한 것이다.
            </exception>
            <remarks>
            현재 구현 상 메서드가 종료하면 수행 문맥은 항상 종료 된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ContextUtil.SetComplete">
            <summary>
            현재 컨텍스트의 <b>ShouldCommit</b> 비트와 <b>Done</b> 비트를 모두 <b>true</b> 로 설정한다.
            따라서 메서드 종료시 수행 문맥이 종료되고 트랜잭션이 <b>Commit</b>이 된다. 
            </summary>
            <exception cref="T:System.InvalidOperationException">
            컨텍스트의 <b>AutoComplete</b> 설정이 <b>true</b> 인 상황에서 <b>SetComplete</b> 혹은 <b>SetAbort</b> 호출이 수행되면 발생한다.
            이는 일관성을 위한 것으로써 <b>AutoComplete</b>가 설정된 상황에서 <b>SetComplete</b> 와 <b>SetAbort</b>를 호출하는 실수를
            막기 위한 것이다.
            </exception>
            <remarks>
            현재 구현 상 <b>Done</b> 비트를 <b>false</b>로 바꾸는 것은 아무런 효과도 없다. 즉, 현재 구현은
            항상 <b>Done</b> 비트가 <b>true</b> 인것 처럼 작동한다. 따라서 메서드가 종료되면 항상
            ExecutionContext가 종료된다.
            </remarks>
        </member>
        <member name="M:TheOne.Transactions.ContextUtil.SetAbort">
            <summary>
            현재 컨텍스트의 <b>ShouldCommit</b> 비트를 <b>false</b>로 설정하고 <b>Done</b> 비트를 <b>true</b>로 설정한다.
            따라서 메서드 종료시 수행 문맥이 종료되고 트랜잭션은 <b>Abort</b>가 되어진다. 
            </summary>
            <exception cref="T:System.InvalidOperationException">
            컨텍스트의 <b>AutoComplete</b> 설정이 <b>true</b> 인 상황에서 <b>SetComplete</b> 혹은 <b>SetAbort</b> 호출이 수행되면 발생한다.
            이는 일관성을 위한 것으로써 <b>AutoComplete</b>가 설정된 상황에서 <b>SetComplete</b> 와 <b>SetAbort</b>를 호출하는 실수를
            막기 위한 것이다.
            </exception>
            <remarks>
            현재 구현 상 <b>Done</b> 비트를 <b>false</b>로 바꾸는 것은 아무런 효과도 없다. 즉, 현재 구현은
            항상 <b>Done</b>  비트가 <b>false</b> 인것 처럼 작동한다. 따라서 메서드가 종료되면 항상
            <see cref="T:TheOne.Transactions.Common.ExecutionContext"> ExecutionContext</see>가 종료된다.
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.ContextId">
            <summary>
            현재 컨텍스트의 ID를 가져온다.
            </summary>
            <value>현재 컨텍스트의 정수 값. 수행 문맥이 존재하지 않는 경우 0 을 가져온다.</value>
            <remarks>
            컨텍스트의 ID 값은 <see href="TheOne.Transactions.Common.ExecutionContext">ExecutionContext</see> 객체의 
            해시 값이 사용된다.
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.ApplicationName">
            <summary>
            현재 컴포넌트의 어플리케이션 이름을 가져온다.
            </summary>
            <value>어플리케이션 이름, 컨텍스트가 존재하지 않는 경우 <b>null</b> 이 반환된다.</value>
            <remarks>
            어플리케이션 이름은 컴포넌트의 수행 통계를 표시하거나 모니터링을 위해서만 사용된다.
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.DeactivationOnReturn">
            <summary>
            메서드 종료 후 컨텍스트의 <b>Done</b> 비트를 가져오거나 설정한다.
            </summary>
            <remarks>
            이 속성은 컨텍스트의 <b>Done</b> 비트를 수정할 수 있도록 해준다. 현재 구현상 <b>Done</b> 비트는 사용되지 않으므로 항상 메서드 종료 후에는 수행
            문맥이 종료되며 수행 문맥이 종료됨에 따라 트랜잭션 역시 종료된다. 즉, 이 속성의 값을 변경하더라도 변화 사항이 없다.
            </remarks>
            <value>메서드 종료 후 컨텍스트의 종료 여부를 나타내는 <b>boolean</b> 값</value>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">
            현재 수행 문맥이 존재하지 않는 경우 발생한다.
            </exception>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.IsInTransaction">
            <summary>
            현재 컨텍스트가 트랜잭션인지 여부를 나타내는 값을 가져오거나 설정한다. 
            </summary>
            <value>트랜잭션 수행 여부를 나타내는 <b>boolean</b> 값</value>
            <remarks>
            	<para>
                    이 속성이 반환하는 값은 <see href="TheOne.Transactions.ComponentBase">ComponentBase</see> 기반의 프레임워크에서
                    관리하는 트랜잭션의 존재 여부만을 반환한다. System.Transactions 네임스페이스나 COM+의 트랜잭션 수행 여부는 관련 네임스페이스의
                    트랜잭션 존재 여부를 통해 확인해야만 한다. 이 속성은 하부 트랜잭션 인프라에 상관없이 트랜잭션 존재 유무를 반환해
                    주기 때문에 편리하다.
                </para>
            </remarks>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.MyTransactionVote">
            <summary>트랜잭션 <b>Commit</b> 혹은 <b>Abort</b> 투표 값을 가져온다.</summary>
            <value>트랜잭션이 커밋될 것이라면 <b>true</b>를 그렇지 않다면 <b>false</b>를 반환한다.</value>
            <remarks>
            이 속성은 컨텍스트의 <b>ShouldCommit</b> 비트의 값을 나타낸다. 따라서 수행 문맥이 <b>AutoComplete</b> 가 <b>true</b>로 설정된 상황이라면
            아무런 의미도 갖지 않는다. 따라서 <b>AutoComplete</b> 가 <b>true</b>인 상황에서 이 속성을 액세스하면 
            <see cref="T:System.InvalidOperationException">InvalidOperationException</see> 예외가 발생한다.
            </remarks>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">
            <b>AutoComplete</b> 가 <b>true</b>로 설정된 상황에서 이 속성을 액세스하면 발생한다.
            </exception>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.IsAutoComplete">
            <summary>
            현재 컨텍스트의 <b>AutoComplete</b> 설정을 가져온다.
            </summary>
            <remarks>
            <b>AutoComplete</b> 설정은 <see href="AutoCompleteAttribute">AutoCompleteAttribute</see> 특성에 의해
            메서드 혹은 클래스 수준에서 설정된다. 클래스 수준에서 설정된 <b>AutoComplete</b> 설정은 각 메서드에
            적용되며 클래스와 메서드 수준에서 모두 <b>AutoComplete</b> 설정이 존재하면 메서드 수준의 설정을 따른다.
            </remarks>
            <value>메서드 종료 후 컨텍스트의 종료 여부를 나타내는 boolean 값</value>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">
            현재 컨텍스트가 존재하지 않는 경우 발생한다.
            </exception>
        </member>
        <member name="P:TheOne.Transactions.ContextUtil.TransactionInfo">
            <summary>
            현재 컨텍스트가 사용하는 트랜잭션 정보를 반환한다.
            </summary>
            <remarks>
            트랜잭션 정보는 트랜잭션 수행 옵션, 격리 수준, 타임아웃을 포함한다. 그리고 이들 정보는
            트랜잭션 인프라(System.Transaction, COM+, Local Transaction 등)에 의해 의미가 다르거나
            지원되는 옵션이 달라질 수 있다.
            </remarks>
            <value>트랜잭션 정보를 나타내는 <see href="TransactionInfo">TransactionInfo</see> 객체</value>
            <exception cref="T:System.InvalidOperationException" caption="InvalidOperationException">
            현재 수행 문맥이 존재하지 않는 경우 발생한다.
            </exception>
        </member>
        <member name="T:TheOne.Transactions.Common.ExecutionServerObjectSink">
            <summary>
            <para>이 클래스는 TheOne Framework 내부에서 사용하기 위한 클래스 이다.</para>
            <para>ExecutionServerObjectSink 클래스는 ComponentBase 에서 파생된 클래스의 인스턴스에 대한
            호출을 가로채어 수행 확장 및 트랜잭션 환경을 구축해 주는 메시지 싱크이다.</para>
            </summary>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionServerObjectSink.ProcessMessage(System.Runtime.Remoting.Messaging.IMessage)">
            <summary>
            메시지를 처리하여 클래스/메서드에 설정된 트랜잭션 속성이 적용되도록 한다.
            </summary>
            <param name="callMessage">메서드 호출을 나타내는 IMessage 객체</param>
            <returns>메서드 호출 결과를 나타내는 IMessage 객체</returns>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionServerObjectSink.System#Runtime#Remoting#Messaging#IMessageSink#AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)">
            <summary>
            <para>IMessageSink 인터페이스의 AsyncProcessMessage 메서드 구현.</para>
            <para>트랜잭션 객체에 대한 비동기 호출은 지원하지 않는다. 따라서 이 메서드는 항상
            NotImplementedException 예외를 발생한다.</para>
            </summary>
            <param name="msg">메시지 객체</param>
            <param name="replySink">결과 메시지 싱크</param>
            <returns>IMessageCtrl 객체</returns>
        </member>
        <member name="M:TheOne.Transactions.Common.ExecutionServerObjectSink.System#Runtime#Remoting#Messaging#IMessageSink#SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)">
            <summary>
            <para>IMessageSink 인터페이스의 SyncProcessMessage 메서드 구현.</para>
            <para>서버 객체에 호출을 가로채어 트랜잭션 처리가 가능하도록 환경을 설정한다.</para>
            </summary>
            <param name="msg">메시지 객체</param>
            <returns>호출 결과에 대한 메시지 객체</returns>
        </member>
        <member name="P:TheOne.Transactions.Common.ExecutionServerObjectSink.System#Runtime#Remoting#Messaging#IMessageSink#NextSink">
            <summary>
            <para>IMessageSink 인터페이스의 NextSink 속성 구현.</para>
            <para>다음 메시지 싱크 객체를 반환한다.</para>
            </summary>
        </member>
    </members>
</doc>
